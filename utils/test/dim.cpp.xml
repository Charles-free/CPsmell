<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C++" filename="dim.cpp" hash="d693d0b171fc051b589449013fb56242a50ce18c"><comment type="line">// Copyright (c) Facebook, Inc. and its affiliates.</comment>
<comment type="line">// All rights reserved.</comment>
<comment type="line">//</comment>
<comment type="line">// This source code is licensed under the BSD-style license found in the</comment>
<comment type="line">// LICENSE file in the root directory of this source tree.</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"minpybind.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;frameobject.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;opcode.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;new&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iostream&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>
<comment type="line">//#include &lt;torch/csrc/autograd/python_variable.h&gt;</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;torch/csrc/utils/python_compat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;torch/csrc/Export.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ATen/functorch/BatchedTensorImpl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ATen/functorch/DynamicLayer.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ATen/ATen.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"python_variable_simple.h"</cpp:file></cpp:include>


<comment type="line">// C++ API functions for objects to</comment>
<comment type="line">// * construct the object, returning a ref-counted handle</comment>
<comment type="line">// * The actual API, with methods that take/return C-typed values</comment>

<comment type="line">// extend minpybind.h to include</comment>
<comment type="line">// * typed handles so that -&gt; can get to their raw API</comment>
<comment type="line">// * object/handle distinction for the typed handles</comment>

<comment type="line">// class Dim: ---------------</comment>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>torch_Tensor___mul__</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>_Tensor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>_Tensor_sum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>NamedTuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>dict_view</name></name></type> <name>pointwise</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>torch_Tensor_expand</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>binaryfunc</name></type> <name>THPVariable_getitem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>objobjargproc</name></type> <name>THPVariable_setitem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>no_slice</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name><modifier>*</modifier></type> <name>torch_Tensor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>torch_Tensor_copy_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>torch_Tensor_split</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>pointwise_optimize</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name><modifier>*</modifier></type> <name>DimType</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>maybeInitializeGlobals</name><parameter_list>()</parameter_list> <block>{<block_content>
    <comment type="line">// globals that depend on the python dim library,</comment>
    <comment type="line">// which we can't lookup until we finish initializing the _C module</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>_Tensor</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>dim</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>import</name></name><argument_list>(<argument><expr><literal type="string">"functorch.dim"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>_Tensor</name> <operator>=</operator> <call><name><name>dim</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"_Tensor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pointwise</name> <operator>=</operator> <call><name><name>dim</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"pointwise"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>_Tensor_sum</name> <operator>=</operator> <call><name><name>_Tensor</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>DimType</name> <operator>=</operator> <operator>(</operator><name>PyTypeObject</name><operator>*</operator><operator>)</operator> <call><name><name>py</name><operator>::</operator><name>import</name></name><argument_list>(<argument><expr><literal type="string">"functorch.dim"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"Dim"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>PyObject</name><modifier>*</modifier></type> <name>Tensor_getitem</name><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>Tensor_setitem</name><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>replaceMappingIfMatches</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>tp</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>T</name> <init>= <expr><operator>(</operator><name>PyTypeObject</name><operator>*</operator><operator>)</operator> <call><name><name>tp</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>recurse</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>tp_as_mapping</name><operator>-&gt;</operator><name>mp_subscript</name></name> <operator>==</operator> <name>THPVariable_getitem</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>tp_as_mapping</name><operator>-&gt;</operator><name>mp_subscript</name></name> <operator>=</operator> <name>Tensor_getitem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>recurse</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>T</name><operator>-&gt;</operator><name>tp_as_mapping</name><operator>-&gt;</operator><name>mp_ass_subscript</name></name> <operator>==</operator> <name>THPVariable_setitem</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>T</name><operator>-&gt;</operator><name>tp_as_mapping</name><operator>-&gt;</operator><name>mp_ass_subscript</name></name> <operator>=</operator> <name>Tensor_setitem</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>recurse</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>result</name> <init>= <expr><call><name><name>tp</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"__subclasses__"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>call</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>list_view</name></name></type> <name>lv</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>lv</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>replaceMappingIfMatches</name><argument_list>(<argument><expr><name><name>lv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>initializeGlobals</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>torch</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>import</name></name><argument_list>(<argument><expr><literal type="string">"torch"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>torch_Tensor</name> <operator>=</operator> <operator>(</operator><name>PyTypeObject</name><operator>*</operator><operator>)</operator> <call><name><name>torch</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"Tensor"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>torch_Tensor___mul__</name> <operator>=</operator> <call><name><name>torch</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"Tensor"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"__mul__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>torch_Tensor_expand</name> <operator>=</operator> <call><name><name>torch</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"_C"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"_TensorBase"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"expand"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>torch_Tensor_split</name> <operator>=</operator> <call><name><name>torch</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"_C"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"_TensorBase"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"split"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>torch_Tensor_copy_</name> <operator>=</operator> <call><name><name>torch</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"Tensor"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"copy_"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>py_TensorBase</name> <init>= <expr><call><name><name>torch</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"_C"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"_TensorBase"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>TensorBase</name> <init>= <expr><operator>(</operator><name>PyTypeObject</name><operator>*</operator><operator>)</operator> <call><name><name>py_TensorBase</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>THPVariable_getitem</name> <operator>=</operator> <name><name>TensorBase</name><operator>-&gt;</operator><name>tp_as_mapping</name><operator>-&gt;</operator><name>mp_subscript</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>THPVariable_setitem</name> <operator>=</operator> <name><name>TensorBase</name><operator>-&gt;</operator><name>tp_as_mapping</name><operator>-&gt;</operator><name>mp_ass_subscript</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>NamedTuple</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>import</name></name><argument_list>(<argument><expr><literal type="string">"typing"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"NamedTuple"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>no_slice</name> <operator>=</operator> <call><name>PySlice_New</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>DimensionBindError_</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>DimensionBindError</name><parameter_list>()</parameter_list> <block>{<block_content>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name><name>DimensionBindError_</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>DimensionBindError_</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>import</name></name><argument_list>(<argument><expr><literal type="string">"functorch.dim"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"DimensionBindError"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>DimensionBindError_</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int64_t</name></type> <name>n_dims_created</name> <init>= <expr><literal type="number">65</literal></expr></init></decl>;</decl_stmt>

<struct>struct <name>Dim</name> <super_list>: <super><specifier>public</specifier> <name><name>py</name><operator>::</operator><name>base</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></super></super_list> <block>{<public type="default">
    <decl_stmt><decl><type><name>int64_t</name></type> <name>level_</name></decl>;</decl_stmt> <comment type="line">// for stable comparisons in prototype</comment>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name_</name></decl>;</decl_stmt>
    <constructor><name>Dim</name><parameter_list>()</parameter_list>
    <member_init_list>: <call><name>level_</name><argument_list>(<argument><expr><name>n_dims_created</name><operator>++</operator></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content/>}</block></constructor>
    <function><type><name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>s</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>name_</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size_</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>bool</name></type> <name>check_exact</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><call><name><name>v</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>DimType</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><name>int64_t</name></type> <name>size</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>size_</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"dimension %S is unbound"</literal></expr></argument>, <argument><expr><call><name><name>name_</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>size_</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>set_size</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>size_</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>size_</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><name>size_</name> <operator>!=</operator> <name>v</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Dim '%R' previously bound to a dimension of size %lld cannot bind to a dimension of size %lld"</literal></expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>size_</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>is_bound</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <return>return <expr><name>size_</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></function>
    <function><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>create</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>s</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>DimType</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>maybeInitializeGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>r</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>alloc</name></name><argument_list>(<argument><expr><name>DimType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>r</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>r</name></expr>;</return>
    </block_content>}</block></function>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Type</name></decl>;</decl_stmt>
    <function><type><specifier>const</specifier> <name><name>at</name><operator>::</operator><name>Tensor</name></name><modifier>&amp;</modifier></type> <name>range</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>range_</name><operator>.</operator><name>defined</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>range_</name> <operator>=</operator> <call><name><name>at</name><operator>::</operator><name>arange</name></name><argument_list>(<argument><expr><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>range_</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><specifier>const</specifier> <name><name>at</name><operator>::</operator><name>Tensor</name></name><modifier>&amp;</modifier></type> <name>batchtensor</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>batchtensor_</name><operator>.</operator><name>defined</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>batchtensor_</name> <operator>=</operator> <call><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>addBatchDim</name></name><argument_list>(<argument><expr><call><name>range</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>level_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>batchtensor_</name></expr>;</return>
    </block_content>}</block></function>
</public><private>private:
    <decl_stmt><decl><type><name>int64_t</name></type> <name>size_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>range_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>batchtensor_</name></decl>;</decl_stmt>
</private>}</block>;</struct>

<struct>struct <name>DimEntry</name> <block>{<public type="default">
    <comment type="line">// union of either a negative number indicating which dimension this is from the rhs,</comment>
    <comment type="line">// or a pointer to a first-class dimension.</comment>
    <comment type="line">// pointers do not have their highest bit set, so checking the number is negative tells us</comment>
    <comment type="line">// that it is not a dim.</comment>
    <function><type><name>bool</name></type> <name>is_positional</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <return>return <expr><name>data_</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>is_none</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <return>return <expr><name>data_</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>int64_t</name></type> <name>position</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <return>return <expr><name>data_</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>dim</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <decl_stmt><decl><type><name>Dim</name><modifier>*</modifier></type> <name>result</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>memcpy</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data_</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Dim</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <constructor><name>DimEntry</name><parameter_list>()</parameter_list>
    <member_init_list>: <call><name>data_</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content/>}</block></constructor>

    <constructor><name>DimEntry</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>
    <member_init_list>: <call><name>data_</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content>
        <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>
    <constructor><name>DimEntry</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>memcpy</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>data_</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>
    <function type="operator"><type><name>bool</name></type> <name>operator<name>==</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DimEntry</name><modifier>&amp;</modifier></type> <name>rhs</name></decl></parameter>)</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <return>return <expr><name>data_</name> <operator>==</operator> <name><name>rhs</name><operator>.</operator><name>data_</name></name></expr>;</return>
    </block_content>}</block></function>
</public><private>private:
    <decl_stmt><decl><type><name>int64_t</name></type> <name>data_</name></decl>;</decl_stmt>
</private>}</block>;</struct>

<function type="operator"><type><name><name>std</name><operator>::</operator><name>ostream</name></name><modifier>&amp;</modifier></type> <name>operator<name>&lt;&lt;</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>ostream</name></name><modifier>&amp;</modifier></type> <name>ss</name></decl></parameter>, <parameter><decl><type><name>DimEntry</name></type> <name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>entry</name><operator>.</operator><name>is_none</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <literal type="string">"None"</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>entry</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <call><name><name>entry</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>ss</name> <operator>&lt;&lt;</operator> <call><name><name>entry</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>ss</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Dim wrapper methods</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>Dim_init</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwds</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"name"</literal></expr>, <expr><literal type="string">"size"</literal></expr>, <expr><literal type="null">nullptr</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>size</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr><literal type="string">"O|O"</literal></expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name><name>size</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument>-<literal type="number">1</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Dim_repr</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name><name>self</name><operator>-&gt;</operator><name>name_</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name><name>self</name><operator>-&gt;</operator><name>name_</name></name></expr> </then><else>: <expr><call><name><name>py</name><operator>::</operator><name>unicode_from_string</name></name><argument_list>(<argument><expr><literal type="string">"&lt;uninitialized dim&gt;"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>name</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Dim_getsize</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <macro><name>PY_BEGIN</name></macro>
    <return>return <expr><call><name><name>py</name><operator>::</operator><name>from_int</name></name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>Dim_setsize</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name><name>self</name><operator>-&gt;</operator><name>set_size</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument>-<literal type="number">1</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Dim_getis_bound</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>is_bound</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Dim_getlevel</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>level_</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Dim_get_levels</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>t</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>t</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Dim_get_has_device</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Dim_get_tensor</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>THPVariable_Wrap</name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Dim_get_batchtensor</name><parameter_list>(<parameter><decl><type><name>Dim</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>THPVariable_Wrap</name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>batchtensor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>Dim_getsetters</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"size"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>Dim_getsize</name></expr>, <expr><operator>(</operator><name>setter</name><operator>)</operator> <name>Dim_setsize</name></expr>,
     <expr><literal type="string">"Dimension size"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"is_bound"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>Dim_getis_bound</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"is_bound"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_level"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>Dim_getlevel</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"_level"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_levels"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>Dim_get_levels</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"_levels"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_has_device"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>Dim_get_has_device</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"_has_device"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_tensor"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>Dim_get_tensor</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"_tensor"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_batchtensor"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>Dim_get_batchtensor</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"_batchtensor"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"ndim"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> -&gt; <type><name>PyObject</name><modifier>*</modifier></type> <block>{<block_content> <return>return <expr><call><name><name>py</name><operator>::</operator><name>from_int</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return> <expr_stmt/>}</block_content></block></lambda></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"ndim"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>  <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name><name>Dim</name><operator>::</operator><name>Type</name></name> <init>= <expr><block>{
    <expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
    <literal type="string">"_C.Dim"</literal></expr>,               <comment type="block">/* tp_name */</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Dim</name></expr></argument>)</argument_list></sizeof></expr>,               <comment type="block">/* tp_basicsize */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_itemsize */</comment>
    <expr><name><name>Dim</name><operator>::</operator><name>dealloc_stub</name></name></expr>,      <comment type="block">/* tp_dealloc */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_vectorcall_offset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_getattr */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_setattr */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_async */</comment>
    <expr><operator>(</operator><name>reprfunc</name><operator>)</operator><name>Dim_repr</name></expr>,           <comment type="block">/* tp_repr */</comment>
    <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* tp_as_number */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_sequence */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_mapping */</comment>
    <expr><literal type="number">0</literal></expr>,      <comment type="block">/* tp_hash */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_call */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_str */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_getattro */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_setattro */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_buffer */</comment>
    <expr><name>Py_TPFLAGS_DEFAULT</name> <operator>|</operator> <name>Py_TPFLAGS_BASETYPE</name></expr>,  <comment type="block">/* tp_flags */</comment>
    <expr><literal type="string">"Dim Object"</literal></expr>,                   <comment type="block">/* tp_doc */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_traverse */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_clear */</comment>
    <expr><literal type="number">0</literal></expr>,  <comment type="block">/* tp_richcompare */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_weaklistoffset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_iter */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_iternext */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_methods */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_members */</comment>
    <expr><name>Dim_getsetters</name></expr>,                 <comment type="block">/* tp_getset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_base */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_dict */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_descr_get */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_descr_set */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_dictoffset */</comment>
    <expr><operator>(</operator><name>initproc</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>Dim_init</name></expr>,     <comment type="block">/* tp_init */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_alloc */</comment>
    <expr><name><name>Dim</name><operator>::</operator><name>new_stub</name></name></expr>,                      <comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="line">// class DimList ------------</comment>

<struct>struct <name>DimList</name> <super_list>: <super><specifier>public</specifier> <name><name>py</name><operator>::</operator><name>base</name><argument_list type="generic">&lt;<argument><expr><name>DimList</name></expr></argument>&gt;</argument_list></name></super></super_list> <block>{<public type="default">
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>dims_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Type</name></decl>;</decl_stmt>
    <function><type><name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>name_</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>set_dims</name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>dims</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>bound_</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>dims_</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>is_bound</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>bound_</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>bind_len</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>bound_</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>b_size</name> <init>= <expr><call><name><name>dims_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>b_size</name> <operator>!=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Dimlist has size %lld but it is being bound to size %d"</literal></expr></argument>, <argument><expr><name>b_size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><name>bound_</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dims_</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>dims_</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>Dim</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>unicode_from_format</name></name><argument_list>(<argument><expr><literal type="string">"%S%i"</literal></expr></argument>, <argument><expr><call><name><name>name_</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>
    <function><type><name>int64_t</name></type> <name>size</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bound_</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"DimList not bound"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>dims_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>set_bound</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>bound_</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
    </block_content>}</block></function>
</public><private>private:
    <decl_stmt><decl><type><name>bool</name></type> <name>bound_</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
</private>}</block>;</struct>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>DimList_init</name><parameter_list>(<parameter><decl><type><name>DimList</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwds</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>DimList_repr</name><parameter_list>(<parameter><decl><type><name>DimList</name><modifier>*</modifier></type> <name>self</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <macro><name>PY_BEGIN</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name><name>self</name><operator>-&gt;</operator><name>is_bound</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name><name>self</name><operator>-&gt;</operator><name>dims_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>t</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for<control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>dims_</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>repr</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if<condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>name_</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>unicode_from_format</name></name><argument_list>(<argument><expr><literal type="string">"*%S"</literal></expr></argument>, <argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>name_</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>unicode_from_string</name></name><argument_list>(<argument><expr><literal type="string">"&lt;unbound_dimlist&gt;"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>DimList_bind</name><parameter_list>(<parameter><decl><type><name>DimList</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>sizes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>_keywords</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"sizes"</literal></expr>, <expr><literal type="null">nullptr</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>_PyArg_Parser</name></type> <name>parser</name> <init>= <expr><block>{<expr><literal type="string">"O"</literal></expr>, <expr><name>_keywords</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_PyArg_ParseStackAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sizes</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_sequence</name></name><argument_list>(<argument><expr><name>sizes</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"expected a sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>seq</name> <init>= <expr><name>sizes</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>size</name> <init>= <expr><call><name><name>seq</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>bind_len</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>dims_</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>set_size</name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name><name>seq</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>DimList_bind_len</name><parameter_list>(<parameter><decl><type><name>DimList</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <name>int</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>_keywords</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"N"</literal></expr>, <expr><literal type="null">nullptr</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>_PyArg_Parser</name></type> <name>parser</name> <init>= <expr><block>{<expr><literal type="string">"i"</literal></expr>, <expr><name>_keywords</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_PyArg_ParseStackAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>bind_len</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>DimList_methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"bind"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>DimList_bind</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"bind_len"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>DimList_bind_len</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>        <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type> <name>DimList_len</name><parameter_list>(<parameter><decl><type><name>DimList</name><modifier>*</modifier></type> <name>self</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <macro><name>PY_BEGIN</name></macro>
    <return>return <expr><call><name><name>self</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument>-<literal type="number">1</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><name>PyObject</name> <modifier>*</modifier></type> <name>DimList_item</name><parameter_list>(<parameter><decl><type><name>DimList</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>Py_ssize_t</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <macro><name>PY_BEGIN</name></macro>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>self</name><operator>-&gt;</operator><name>is_bound</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"DimList not bound"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>idx</name> <operator>&gt;=</operator> <call><name><name>self</name><operator>-&gt;</operator><name>dims_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr><literal type="string">"index out of bounds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>r</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>dims_</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>r</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<decl_stmt><decl><type><name>PySequenceMethods</name></type> <name>DimList_seq</name> <argument_list>{
    <argument><expr><operator>(</operator><name>lenfunc</name><operator>)</operator> <name>DimList_len</name></expr></argument>, <comment type="line">//lenfunc sq_length;</comment>
    <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="line">//binaryfunc sq_concat;</comment>
    <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="line">//ssizeargfunc sq_repeat;</comment>
    <argument><expr><operator>(</operator><name>ssizeargfunc</name><operator>)</operator> <name>DimList_item</name></expr></argument>, <comment type="line">//ssizeargfunc sq_item;</comment>
    <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="line">//void *was_sq_slice;</comment>
    <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="line">//ssizeobjargproc sq_ass_item;</comment>
    <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="line">//void *was_sq_ass_slice;</comment>
    <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="line">//objobjproc sq_contains;</comment>

    <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="line">//binaryfunc sq_inplace_concat;</comment>
    <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="line">//ssizeargfunc sq_inplace_repeat;</comment>
}</argument_list></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>DimList_getis_bound</name><parameter_list>(<parameter><decl><type><name>DimList</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>is_bound</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>DimList_getsetters</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"is_bound"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>DimList_getis_bound</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"is_bound"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>  <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>DimList_subscript</name><parameter_list>(<parameter><decl><type><name>DimList</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <macro><name>PY_BEGIN</name></macro>
    <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_int</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>DimList_item</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_slice</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>self</name><operator>-&gt;</operator><name>is_bound</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"DimList not bound"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>slice_view</name></name></type> <name>s</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>dims_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>r</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>slicelength</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>s</name><operator>.</operator><name>start</name></name></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>.</operator><name>stop</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name><name>s</name><operator>.</operator><name>step</name></name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>j</name><operator>++</operator></expr></argument>,  <argument><expr><name><name>self</name><operator>-&gt;</operator><name>dims_</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>r</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"expected an int or a slice"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<decl_stmt><decl><type><name>PyMappingMethods</name></type> <name>DimList_mapping</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>, <comment type="line">//lenfunc mp_length;</comment>
    <expr><operator>(</operator><name>binaryfunc</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>DimList_subscript</name></expr>, <comment type="line">//binaryfunc mp_subscript;</comment>
    <expr><literal type="number">0</literal></expr>, <comment type="line">//objobjargproc mp_ass_subscript;</comment>
}</block></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>PyTypeObject</name></type> <name><name>DimList</name><operator>::</operator><name>Type</name></name> <init>= <expr><block>{
    <expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
    <literal type="string">"_C.DimList"</literal></expr>,               <comment type="block">/* tp_name */</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>DimList</name></expr></argument>)</argument_list></sizeof></expr>,               <comment type="block">/* tp_basicsize */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_itemsize */</comment>
    <expr><name><name>DimList</name><operator>::</operator><name>dealloc_stub</name></name></expr>,      <comment type="block">/* tp_dealloc */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_vectorcall_offset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_getattr */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_setattr */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_async */</comment>
    <expr><operator>(</operator><name>reprfunc</name><operator>)</operator><name>DimList_repr</name></expr>,           <comment type="block">/* tp_repr */</comment>
    <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* tp_as_number */</comment>
    <expr><operator>&amp;</operator><name>DimList_seq</name></expr>,                 <comment type="block">/* tp_as_sequence */</comment>
    <expr><operator>&amp;</operator><name>DimList_mapping</name></expr>,             <comment type="block">/* tp_as_mapping */</comment>
    <expr><literal type="number">0</literal></expr>,      <comment type="block">/* tp_hash */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_call */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_str */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_getattro */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_setattro */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_buffer */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_flags */</comment>
    <expr><literal type="string">"DimList Object"</literal></expr>,                   <comment type="block">/* tp_doc */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_traverse */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_clear */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_richcompare */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_weaklistoffset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_iter */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_iternext */</comment>
    <expr><name>DimList_methods</name></expr>,                <comment type="block">/* tp_methods */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_members */</comment>
    <expr><name>DimList_getsetters</name></expr>,             <comment type="block">/* tp_getset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_base */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_dict */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_descr_get */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_descr_set */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_dictoffset */</comment>
    <expr><operator>(</operator><name>initproc</name><operator>)</operator> <name>DimList_init</name></expr>,            <comment type="block">/* tp_init */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_alloc */</comment>
    <expr><name><name>DimList</name><operator>::</operator><name>new_stub</name></name></expr>,                      <comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>DimList_init</name><parameter_list>(<parameter><decl><type><name>DimList</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwds</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"len_or_dims"</literal></expr>, <expr><literal type="string">"name"</literal></expr>, <expr><literal type="null">nullptr</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>len_or_dims</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>name</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr><literal type="string">"|OO"</literal></expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len_or_dims</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><name>name</name></expr> </then><else>: <expr><name>Py_None</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>len_or_dims</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_int</name></name><argument_list>(<argument><expr><name>len_or_dims</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>bind_len</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>len_or_dims</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_sequence</name></name><argument_list>(<argument><expr><name>len_or_dims</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>s</name><argument_list>(<argument><expr><name>len_or_dims</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>dims</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>dims</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>r</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_int</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>dims</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><call><name><name>Dim</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>unicode_from_format</name></name><argument_list>(<argument><expr><literal type="string">"%S%i"</literal></expr></argument>, <argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>name_</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>,  <argument><expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <expr_stmt><expr><call><name><name>dims</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><call><name><name>Dim</name><operator>::</operator><name>wrap</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>set_dims</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"expected a length or a sequence of dimensions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
    <expr_stmt><expr><call><name>PY_END</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Tensor -----------------------------</comment>

<decl_stmt><decl><type><name>PyTypeObject</name><modifier>*</modifier></type> <name>TensorType</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt> <comment type="line">// the python wrapper type.</comment>
<function_decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>_add_batch_dims</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels_</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>run_torch_function</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pointwise</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>free_levels_dims</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>)</parameter_list>;</function_decl>

<struct_decl>struct <name>Tensor</name>;</struct_decl>

<struct>struct <name>DelayedOperator</name> <block>{<public type="default">
    <constructor><name>DelayedOperator</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>a</name></decl></parameter>)</parameter_list>
    <member_init_list>: <call><name>orig</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>, <call><name>args</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> </member_init_list><block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>all</name> <init>= <expr><call><name><name>a</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// this will outlive the call so</comment>
        <comment type="line">// take ownership of temporaries</comment>
        <comment type="line">// in vector args</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>buf</name> <init>= <expr><operator>new</operator> <name><name>py</name><operator>::</operator><name>handle</name><index>[<expr><name>all</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><operator>.</operator><name>args</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>args</name><operator>.</operator><name>enumerate_all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><call><name><name>args</name><operator>.</operator><name>kwnames</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></constructor>
    <destructor><name>~DelayedOperator</name><parameter_list>()</parameter_list> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>args</name><operator>.</operator><name>enumerate_all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><call><name><name>args</name><operator>.</operator><name>has_keywords</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><call><name><name>args</name><operator>.</operator><name>kwnames</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>delete</operator> <index>[]</index> <name><name>args</name><operator>.</operator><name>args</name></name></expr>;</expr_stmt>
    </block_content>}</block></destructor>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>orig</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>args</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<struct>struct <name>Tensor</name> <super_list>: <super><specifier>public</specifier> <name><name>py</name><operator>::</operator><name>base</name><argument_list type="generic">&lt;<argument><expr><name>Tensor</name></expr></argument>&gt;</argument_list></name></super></super_list> <block>{<public type="default">
</public><private>private:
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>tensor_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>batchtensor_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>OwnedSlice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_device_</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>DelayedOperator</name></expr></argument>&gt;</argument_list></name></type> <name>delayed_</name></decl>;</decl_stmt>
</private><public>public:

    <function><type><name><name>at</name><operator>::</operator><name>Tensor</name></name><modifier>&amp;</modifier></type> <name>tensor</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>C10_UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>tensor_</name><operator>.</operator><name>defined</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>delayed_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>auto</name></type> <name>t</name> <init>= <expr><call><name><name>Tensor</name><operator>::</operator><name>wrap</name></name><argument_list>(<argument><expr><call><name>run_torch_function</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>delayed_</name><operator>-&gt;</operator><name>orig</name></name></expr></argument>, <argument><expr><name><name>delayed_</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>tensor_</name> <operator>=</operator> <call><name><name>t</name><operator>-&gt;</operator><name>tensor</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>delayed_</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// don't force creation of batch tensor if it wasn't alreay provided.</comment>
            <expr_stmt><expr><name>batchtensor_</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>batchtensor_</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name>levels</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>t</name><operator>-&gt;</operator><name>levels</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>tensor_</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name><name>at</name><operator>::</operator><name>Tensor</name></name><modifier>&amp;</modifier></type> <name>batchtensor</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>C10_UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>batchtensor_</name><operator>.</operator><name>defined</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>batchtensor_</name> <operator>=</operator> <call><name>_add_batch_dims</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>levels_</name><operator>.</operator><name>slice</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>batchtensor_</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>levels_</name><operator>.</operator><name>slice</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>bool</name></type> <name>has_device</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><name>has_device_</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>DelayedOperator</name><modifier>*</modifier></type> <name>delayed</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>delayed_</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Type</name></decl>;</decl_stmt>

    <function><type><specifier>static</specifier> <name>bool</name></type> <name>check_exact</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
       <return>return <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><call><name><name>v</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>TensorType</name></expr>;</return>
    </block_content>}</block></function>


    <function><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Tensor</name></expr></argument>&gt;</argument_list></name></type> <name>create</name><parameter_list>()</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>TensorType</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>TensorType</name> <operator>=</operator> <operator>(</operator><name>PyTypeObject</name><operator>*</operator><operator>)</operator> <call><name><name>py</name><operator>::</operator><name>import</name></name><argument_list>(<argument><expr><literal type="string">"functorch.dim"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"Tensor"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>alloc</name></name><argument_list>(<argument><expr><name>TensorType</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>capture_levels</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// grab ownership of the dims inside levels</comment>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name>levels</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>levels_</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>levels</name></expr></argument>, <argument><expr><name>free_levels_dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
    <function_decl><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>from_positional</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>tensor</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_device</name></decl></parameter>)</parameter_list>;</function_decl>
    <function_decl><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Tensor</name></expr></argument>&gt;</argument_list></name></type> <name>create_delayed</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_device</name></decl></parameter>)</parameter_list>;</function_decl>
    <friend>friend <struct_decl>struct <name>EnableAllLayers</name>;</struct_decl></friend>
</public>}</block>;</struct>

<function><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>_add_batch_dims</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels_</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>levels</name> <init>= <expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>levels_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>min_real_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>min_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>min_value</name> <init>= <expr><name>INT_MAX</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name>levels</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>l</name><operator>.</operator><name>is_none</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>level_</name> <operator>&lt;</operator> <name>min_value</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>min_value</name> <operator>=</operator> <call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>level_</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>min_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>min_real_index</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>++</operator><name>r</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>min_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>t</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>t2</name> <init>= <expr><call><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>addBatchDim</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>min_index</name></expr></argument>, <argument><expr><name>min_value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>levels</name><index>[<expr><name>min_real_index</name></expr>]</index></name> <operator>=</operator> <call><name>DimEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>free_levels_dims</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <for>for<control>(<init><decl><type><name>auto</name></type> <name>e</name> <range>: <expr><name>levels</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>e</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>steal</name></name><argument_list>(<argument><expr><call><name><name>e</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// version in header does a unnecessary refcount +/-</comment>
<function><type><specifier>inline</specifier> <name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>BatchedTensorImpl</name></name><modifier>*</modifier></type> <name>maybeGetBatchedImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>at</name><operator>::</operator><name>Tensor</name></name><modifier>&amp;</modifier></type> <name>tensor</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>isBatchedTensor</name></name><argument_list>(<argument><expr><name>tensor</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><cast type="static">static_cast<argument_list type="generic">&lt;<argument><expr><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>BatchedTensorImpl</name></name><operator>*</operator></expr></argument>&gt;</argument_list><argument_list>(<argument><expr><call><name><name>tensor</name><operator>.</operator><name>unsafeGetTensorImpl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></cast></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>TensorRef</name></type> <name>unchecked_tensor_from</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>THPVariable</name><operator>*</operator><operator>)</operator> <call><name><name>p</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>TensorRef</name><argument_list>(<argument><expr><operator>*</operator><name><name>v</name><operator>-&gt;</operator><name>cdata</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type> <name>ndim_of_levels</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name>levels</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>r</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>TensorInfo</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>TensorRef</name></type> <name>tensor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_device</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TensorRef</name></type> <name>batchedtensor</name></decl>;</decl_stmt>
    <function><type><name>int64_t</name></type> <name>ndim</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <return>return <expr><call><name>ndim_of_levels</name><argument_list>(<argument><expr><name>levels</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <function type="operator"><name>operator <name>bool</name></name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{<block_content>
        <return>return <expr><name>tensor</name></expr>;</return>
    </block_content>}</block></function>

    <function><type><specifier>static</specifier> <name>TensorInfo</name></type> <name>create</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ensure_batched</name><init>=<expr><literal type="boolean">true</literal></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ensure_present</name><init>=<expr><literal type="boolean">true</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>Tensor</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>t</name> <init>= <expr><call><name><name>Tensor</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>TensorInfo</name> <argument_list>{<argument><expr><call><name><name>t</name><operator>-&gt;</operator><name>tensor</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>t</name><operator>-&gt;</operator><name>levels</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>t</name><operator>-&gt;</operator><name>has_device</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ensure_batched</name> <operator>?</operator> <call><name><name>t</name><operator>-&gt;</operator><name>batchtensor</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>TensorRef</name><argument_list>()</argument_list></macro></expr></argument>}</argument_list></call></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><call><name>TensorInfo</name> <argument_list>{<argument><expr><call><name><name>d</name><operator>-&gt;</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>DimEntry</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>ensure_batched</name> <operator>?</operator> <call><name><name>d</name><operator>-&gt;</operator><name>batchtensor</name></name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>TensorRef</name><argument_list>()</argument_list></macro></expr></argument>}</argument_list></call></expr>;</return>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>TensorRef</name></type> <name>t</name> <init>= <expr><call><name>unchecked_tensor_from</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><operator>-</operator><call><name><name>t</name><operator>-&gt;</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <return>return <expr><call><name>TensorInfo</name> <argument_list>{<argument><expr><name>t</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>}</argument_list></call></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ensure_present</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"expected a tensor object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><call><name>TensorInfo</name> <argument_list>{}</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></function>


</public>}</block>;</struct>

<function><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>tensor</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_device</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>seen_dims</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="line">//auto sz = tensor.sizes();</comment>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>levels</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>l</name> <init>= <expr><name><name>levels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>last</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>last</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name><name>l</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>last</name> <operator>=</operator> <call><name><name>l</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">//AT_ASSERT(sz[i] == l.dim()-&gt;size());</comment>
            <expr_stmt><expr><operator>++</operator><name>seen_dims</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>last</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>last</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>seen_dims</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>steal</name></name><argument_list>(<argument><expr><call><name>THPVariable_Wrap</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>tensor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Tensor</name></expr></argument>&gt;</argument_list></name></type> <name>self</name> <init>= <expr><call><name><name>Tensor</name><operator>::</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>tensor_</name></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>tensor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>tensor_</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>levels_</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>levels</name></expr></argument>, <argument><expr><name>free_levels_dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>has_device_</name></name> <operator>=</operator> <name>has_device</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>r</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>py_Tensor_from_positional</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGS</name><parameter_list>(<parameter><type><name>_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_(py::handle, tensor) _(py::handle, py_levels) _(int, has_device)</cpp:value></cpp:define>
    <name>MPY_PARSE_ARGS_KWNAMES</name><argument_list>(<argument><expr><literal type="string">"OOp"</literal></expr></argument>, <argument><expr><name>ARGS</name></expr></argument>)</argument_list>
    <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ARGS</name></cpp:undef>

    if <argument_list>(<argument><expr><operator>!</operator><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>tensor</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list> <argument_list>{
        <argument><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"_tensor is not a Tensor?"</literal></expr></argument>)</argument_list></call></expr></argument>;
    }</argument_list>

    <name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name> <name>levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>sq</name><argument_list>(<argument><expr><name>py_levels</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>sq</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>v</name> <init>= <expr><name><name>sq</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_int</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>vi</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>vi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>dim</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>wrap</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>hdim</name> <init>= <expr><name>dim</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>hdim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>THPVariable_Unpack</name><argument_list>(<argument><expr><call><name><name>tensor</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>levels</name></expr></argument>, <argument><expr><name>has_device</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Tensor</name></expr></argument>&gt;</argument_list></name></type> <name><name>Tensor</name><operator>::</operator><name>create_delayed</name></name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_device</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Tensor</name></expr></argument>&gt;</argument_list></name></type> <name>self</name> <init>= <expr><call><name><name>Tensor</name><operator>::</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>capture_levels</name></name><argument_list>(<argument><expr><name>levels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>has_device_</name></name> <operator>=</operator> <name>has_device</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>delayed_</name></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>DelayedOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>self</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>py</name><operator>::</operator><name>list</name></name></type> <name>slice_to_list</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>list</name></name></type> <name>lst</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>h</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name><name>h</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>lst</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>slice_to_tuple</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>lst</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>h</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>lst</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name><name>h</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>lst</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>UType</name> <block>{
    <decl><name>U_ELEM</name></decl>,
    <decl><name>U_TUPLE_LIKE</name></decl>,
    <decl><name>U_DICT</name></decl>,
}</block>;</enum>

<struct>struct <name>Unflatten</name> <block>{<public type="default">
    <function type="operator"><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>operator<name>()</name></name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>elements</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>r</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
            <case>case <expr><name>U_ELEM</name></expr>:</case> <block>{<block_content>
                <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name><name>elements</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>elements</name> <operator>=</operator> <call><name><name>elements</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <break>break;</break>
            <case>case <expr><name>U_TUPLE_LIKE</name></expr>:</case> <block>{<block_content>
                <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>tup</name><argument_list>(<argument><expr><call><name><name>children</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>children</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                    <macro><name>tup</name></macro><expr_stmt><expr><operator>.</operator><macro><name>set</name><argument_list>(<argument>i</argument>, <argument>children[i](elements)</argument>)</argument_list></macro></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>obj</name><operator>.</operator><name>call</name></name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block> <break>break;</break>
            <case>case <expr><name>U_DICT</name></expr>:</case> <block>{<block_content>
                <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>checked_steal</name></name><argument_list>(<argument><expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>dict_view</name></name></type> <name>rv</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>dict_view</name></name></type> <name>d</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><call><name><name>d</name><operator>.</operator><name>next</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                    <macro><name>rv</name></macro><expr_stmt><expr><operator>.</operator><macro><name>set</name><argument_list>(<argument>k</argument>, <argument>children[i](elements)</argument>)</argument_list></macro></expr>;</expr_stmt>
                </block_content>}</block></for>
            </block_content>}</block> <break>break;</break>
        </block_content>}</block></switch>
        <return>return <expr><name>r</name></expr>;</return>
    </block_content>}</block></function>
    <decl_stmt><decl><type><name>UType</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>obj</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>Unflatten</name></expr></argument>&gt;</argument_list></name></type> <name>children</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>Unflatten</name></type> <name>tree_flatten</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>agg</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>flat_elements</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>Unflatten</name></expr></argument>&gt;</argument_list></name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>UType</name></type> <name>utype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>obj</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>list_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name><name>agg</name><operator>.</operator><name>type</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>utype</name> <operator>=</operator> <name>U_TUPLE_LIKE</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>list_view</name></name></type> <name>l</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>l</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>tree_flatten</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>l</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>flat_elements</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name><name>agg</name><operator>.</operator><name>type</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>utype</name> <operator>=</operator> <name>U_TUPLE_LIKE</name></expr>;</expr_stmt>
        <comment type="line">// includes named tuples</comment>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple_view</name></name></type> <name>l</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>l</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>tree_flatten</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>l</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>flat_elements</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>dict_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>utype</name> <operator>=</operator> <name>U_DICT</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>dict_view</name></name></type> <name>d</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><name>obj</name> <operator>=</operator> <name>agg</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>d</name><operator>.</operator><name>next</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>c</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>tree_flatten</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>flat_elements</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>utype</name> <operator>=</operator> <name>U_ELEM</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>flat_elements</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><call><name>Unflatten</name> <argument_list>{<argument><expr><name>utype</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>c</name></expr></argument>}</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>UnflattenVectorArgs</name> <block>{<public type="default">
    <function type="operator"><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>operator<name>()</name></name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>elements</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>had_nested</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>args</name> <init>= <expr><call><name><name>elements</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>elements</name> <operator>=</operator> <call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>py</name><operator>::</operator><name>vector_args</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>args</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>u</name> <range>: <expr><name>children</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>args</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name>u</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>vector_args</name></name><argument_list>(<argument><expr><call><name><name>args</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>Unflatten</name></expr></argument>&gt;</argument_list></name></type> <name>children</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>kwnames</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>had_nested</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><name>UnflattenVectorArgs</name></type> <name>tree_flatten</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>flat_elements</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>UnflattenVectorArgs</name></type> <name>r</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>kwnames</name></name> <operator>=</operator> <name><name>args</name><operator>.</operator><name>kwnames</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name><name>args</name><operator>.</operator><name>nargs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>had_nested</name></name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>N</name> <init>= <expr><call><name><name>args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for<control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>typ</name> <init>= <expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// fast checks that this thing isn't something that is nested.</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>is_element</name> <init>= <expr><operator>!</operator><name><name>typ</name><operator>-&gt;</operator><name>tp_as_sequence</name></name> <operator>||</operator>  <name>typ</name> <operator>==</operator> <name>torch_Tensor</name> <operator>||</operator> <name>typ</name> <operator>==</operator> <name>TensorType</name> <operator>||</operator> <name>typ</name> <operator>==</operator> <name>DimType</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_element</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>flat_elements</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>args</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>j</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>j</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>children</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>Unflatten</name> <argument_list>{<argument><expr><name>U_ELEM</name></expr></argument>}</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>j</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>children</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>tree_flatten</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>flat_elements</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>r</name><operator>.</operator><name>children</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>type</name> <operator>!=</operator> <name>U_ELEM</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name><name>r</name><operator>.</operator><name>had_nested</name></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <return>return <expr><name>r</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>flat_elements</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>args</name></name> <operator>+</operator> <name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<struct>struct <name>UnflattenArena</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Unflatten</name></type> <name>unflatten</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>py_unflatten</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGS</name><parameter_list>(<parameter><type><name>_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_(py::handle, ns)</cpp:value></cpp:define>
    <name>MPY_PARSE_ARGS_KWNAMES</name><argument_list>(<argument><expr><literal type="string">"O"</literal></expr></argument>, <argument><expr><name>ARGS</name></expr></argument>)</argument_list>
    <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ARGS</name></cpp:undef>
    <name><name>py</name><operator>::</operator><name>sequence_view</name></name> <name>sv</name><argument_list>(<argument><expr><name>ns</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// because we do not have a autorelase pool yet...</comment>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>slice</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>Tuple</name> <init>= <expr><operator>(</operator><name>PyObject</name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>PyTuple_Type</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>inputs</name> <init>= <expr><call><name><name>Tuple</name><operator>.</operator><name>call</name></name><argument_list>(<argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple_view</name></name></type> <name>tv</name><argument_list>(<argument><expr><name>inputs</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>tv</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>slice</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>tv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>auto</name></type> <name>AA</name> <init>= <expr><operator>(</operator><name>UnflattenArena</name><operator>*</operator><operator>)</operator> <call><name>PyCapsule_GetPointer</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="string">"arena"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>r</name> <init>= <expr><call><name><name>AA</name><operator>-&gt;</operator><name>unflatten</name></name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>r</name> <operator>!=</operator> <literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>r</name></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<decl_stmt><decl><type><name>PyMethodDef</name></type> <name>py_unflatten_def</name> <init>= <expr><block>{<expr><literal type="string">"unflatten"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py_unflatten</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>free_unflatten_arena</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type> <name>pc</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><operator>delete</operator> <operator>(</operator><name>UnflattenArena</name><operator>*</operator><operator>)</operator> <call><name>PyCapsule_GetPointer</name><argument_list>(<argument><expr><name>pc</name></expr></argument>, <argument><expr><literal type="string">"arena"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>py_tree_flatten</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGS</name><parameter_list>(<parameter><type><name>_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_(py::handle, tree)</cpp:value></cpp:define>
    <name>MPY_PARSE_ARGS_KWNAMES</name><argument_list>(<argument><expr><literal type="string">"O"</literal></expr></argument>, <argument><expr><name>ARGS</name></expr></argument>)</argument_list>
    <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ARGS</name></cpp:undef>
    auto <name>A</name> <init>= <expr><operator>new</operator> <name>UnflattenArena</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>elements</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>A</name><operator>-&gt;</operator><name>unflatten</name></name> <operator>=</operator> <call><name>tree_flatten</name><argument_list>(<argument><expr><name><name>A</name><operator>-&gt;</operator><name>A</name></name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>cap</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>checked_steal</name></name><argument_list>(<argument><expr><call><name>PyCapsule_New</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="string">"arena"</literal></expr></argument>, <argument><expr><name>free_unflatten_arena</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>unflatten</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>checked_steal</name></name><argument_list>(<argument><expr><call><name>PyCFunction_New</name><argument_list>(<argument><expr><operator>&amp;</operator><name>py_unflatten_def</name></expr></argument>, <argument><expr><call><name><name>cap</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>r</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>slice_to_list</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>unflatten</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>r</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>



<function><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>tree_map</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>function</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name><operator>(</operator><name><name>py</name><operator>::</operator><name>handle</name></name><operator>)</operator></expr></argument>&gt;</argument_list></name></type> <name>fn</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>agg</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>elements</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>unflatten</name> <init>= <expr><call><name>tree_flatten</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>, <argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>elements</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>elements</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>fn</name><argument_list>(<argument><expr><name><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name>unflatten</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// prereq: isinstance(h, _Tensor)</comment>
<function><type><specifier>inline</specifier> <name>int64_t</name></type> <name>_Tensor_ndim</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>Tensor</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><call><name><name>Tensor</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>levels</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><operator>++</operator><name>r</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>r</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Dim or DelayedMulTensor</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>handle_from_tensor</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>TensorRef</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// fast case: tensor is live in python</comment>
    <decl_stmt><decl><type><name><name>c10</name><operator>::</operator><name>optional</name><argument_list type="generic">&lt;<argument><expr><name>PyObject</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>mb_obj</name> <init>=
        <expr><call><name><name>t</name><operator>-&gt;</operator><name>unsafeGetTensorImpl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>check_pyobj</name><argument_list>(<argument><expr><call><name>getPyInterpreter</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>mb_obj</name><operator>.</operator><name>has_value</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>t</name><operator>-&gt;</operator><name>unsafeGetTensorImpl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>owns_pyobj</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><operator>*</operator><name>mb_obj</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>checked_steal</name></name><argument_list>(<argument><expr><call><name>THPVariable_Wrap</name><argument_list>(<argument><expr><operator>*</operator><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>EnableAllLayers</name> <block>{<public type="default">
    <constructor><name>EnableAllLayers</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>layers</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>layers</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name>levels</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>levels_to_dim_</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>sort</name></name><argument_list>(<argument><expr><call><name><name>levels_to_dim_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>levels_to_dim_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name><name>lhs</name><operator>-&gt;</operator><name>level_</name></name> <operator>&lt;</operator> <name><name>rhs</name><operator>-&gt;</operator><name>level_</name></name></expr>;</return></block_content>}</block></lambda></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>levels_to_dim_</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>batch_size</name> <init>= <expr><name><name>levels_to_dim_</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>auto</name></type> <name>level</name> <init>= <expr><call><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>initAndPushDynamicLayer</name></name><argument_list>(<argument><expr><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>TransformType</name><operator>::</operator><name>Vmap</name></name></expr></argument>, <argument><expr><name>batch_size</name></expr></argument>, <argument><expr><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>RandomnessType</name><operator>::</operator><name>Different</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>levels_start_</name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></constructor>

    <destructor><name>~EnableAllLayers</name><parameter_list>()</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>to_remove</name> <init>= <expr><name>levels_start_</name> <operator>+</operator> <call><name><name>levels_to_dim_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>levels_to_dim_</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>popDynamicLayerAndDeleteMetadata</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>layerId</name><argument_list>()</argument_list></call> <operator>==</operator> <name>to_remove</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></destructor>

    <function><type><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Tensor</name></expr></argument>&gt;</argument_list></name></type> <name>from_batched</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>batchedtensor</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_device</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><operator>-</operator><call><name><name>batchedtensor</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name>TensorRef</name></type> <name>tensor</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>BatchedTensorImpl</name></name> <modifier>*</modifier></type> <name>impl</name> <init>= <expr><call><name>maybeGetBatchedImpl</name><argument_list>(<argument><expr><name>batchedtensor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr><literal type="boolean">true</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>level</name> <init>= <expr><call><name><name>impl</name><operator>-&gt;</operator><name>level</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>level</name> <operator>&gt;=</operator> <name>levels_start_</name> <operator>&amp;&amp;</operator> <name>level</name> <operator>&lt;</operator> <name>levels_start_</name> <operator>+</operator> <call><name><name>levels_to_dim_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>dim</name> <init>= <expr><name><name>levels_to_dim_</name><index>[<expr><name>level</name> <operator>-</operator> <name>levels_start_</name></expr>]</index></name><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>levels</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>impl</name><operator>-&gt;</operator><name>bdim</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>functorch</name><operator>::</operator><name>BatchedTensorImpl</name></name> <modifier>*</modifier></type> <name>nimpl</name> <init>= <expr><call><name>maybeGetBatchedImpl</name><argument_list>(<argument><expr><call><name><name>impl</name><operator>-&gt;</operator><name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nimpl</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>tensor</name> <operator>=</operator> <call><name><name>impl</name><operator>-&gt;</operator><name>value</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>impl</name> <operator>=</operator> <name>nimpl</name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Tensor</name></expr></argument>&gt;</argument_list></name></type> <name>self</name> <init>= <expr><call><name><name>Tensor</name><operator>::</operator><name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// grab ownership of the tensors</comment>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>tensor_</name></name> <operator>=</operator> <operator>*</operator><name>tensor</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>batchtensor_</name></name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>batchedtensor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>has_device_</name></name> <operator>=</operator> <name>has_device</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>self</name><operator>-&gt;</operator><name>capture_levels</name></name><argument_list>(<argument><expr><name>levels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>self</name></expr>;</return>
    </block_content>}</block></function>
    <function><type><name>void</name></type> <name>inplace_update_layers</name><parameter_list>(<parameter><decl><type><name>TensorRef</name></type> <name>batchtensor</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <comment type="line">// XXX - requires a patch to functorch to att set_level</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>impl</name> <init>= <expr><call><name>maybeGetBatchedImpl</name><argument_list>(<argument><expr><operator>*</operator><name>batchtensor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>levels_to_dim_</name><operator>.</operator><name>reversed_enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>impl</name></expr>)</condition> <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>levels_to_dim_</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>impl</name><operator>-&gt;</operator><name>_unsafe_set_level</name></name><argument_list>(<argument><expr><name>levels_start_</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>impl</name> <operator>=</operator> <call><name>maybeGetBatchedImpl</name><argument_list>(<argument><expr><call><name><name>impl</name><operator>-&gt;</operator><name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></function>
</public><private>private:
    <decl_stmt><decl><type><name>int64_t</name></type> <name>levels_start_</name><argument_list>{}</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>levels_to_dim_</name></decl>;</decl_stmt>
</private>}</block>;</struct>

<function><type><name>TensorRef</name></type> <name>_match_levels</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>TensorRef</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>from_levels</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>to_levels</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>drop_levels</name><init>=<expr><literal type="boolean">false</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>from_levels</name> <operator>==</operator> <name>to_levels</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>v</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// drop_levels -&gt; if a dim appears in from_levels but not to_levels, it is assumed it has stride 0.</comment>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name></type> <name>sz</name> <init>= <expr><call><name><name>v</name><operator>-&gt;</operator><name>sizes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name></type> <name>sd</name> <init>= <expr><call><name><name>v</name><operator>-&gt;</operator><name>strides</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>drop_levels</name> <operator>||</operator> <call><name><name>from_levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <call><name><name>to_levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>nsz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>nsd</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name>to_levels</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>oidx</name> <init>= <expr><call><name><name>from_levels</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>oidx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>nsz</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>size</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>nsd</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>idx</name> <init>= <expr><operator>*</operator><name>oidx</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>nsz</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sz</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>nsd</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sd</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>v</name><operator>-&gt;</operator><name>as_strided</name></name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>nsz</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>nsz</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>nsd</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>nsd</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>v</name><operator>-&gt;</operator><name>storage_offset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>run_torch_function</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pointwise</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pointwise_optimize</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>is_pointwise</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// std::cout &lt;&lt; "__torch_function__ " &lt;&lt; ((is_pointwise) ? "pointwise" : "functorch") &lt;&lt; " " &lt;&lt; orig &lt;&lt; "\n";</comment>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>all_dims</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>flat_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>unflatten_args</name> <init>= <expr><call><name>tree_flatten</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>flat_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TensorRef</name></type> <name>device_holding_tensor</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>TensorInfo</name></expr></argument>&gt;</argument_list></name></type> <name>infos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>result_levels</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>f</name> <range>: <expr><name>flat_args</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>infos</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>!</operator><name>is_pointwise</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>infos</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>TensorInfo</name><modifier>&amp;</modifier></type> <name>info</name> <init>= <expr><call><name><name>infos</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>is_pointwise</name> <operator>||</operator> <name><name>info</name><operator>.</operator><name>batchedtensor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>device_holding_tensor</name> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>has_device</name></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>device_holding_tensor</name> <operator>=</operator> <call><name><name>infos</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>tensor</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name><name>info</name><operator>.</operator><name>levels</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>result_levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>result_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>is_pointwise</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>flat_args</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>infos</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>TensorRef</name></type> <name>tensor</name> <init>= <expr><name><name>infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tensor</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>device_holding_tensor</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>has_device</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>tensor</name> <operator>=</operator> <call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>tensor</name><operator>-&gt;</operator><name>to</name></name><argument_list>(<argument><expr><call><name><name>device_holding_tensor</name><operator>-&gt;</operator><name>device</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <decl_stmt><decl><type><name>auto</name></type> <name>ml</name> <init>= <expr><call><name>_match_levels</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>tensor</name></expr></argument>, <argument><expr><name><name>infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>levels</name></expr></argument>, <argument><expr><name>result_levels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>flat_args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>handle_from_tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>ml</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>flat_it</name> <init>= <expr><name>flat_args</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>uargs</name> <init>= <expr><call><name>unflatten_args</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>flat_it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>result</name> <init>= <expr><call><name><name>orig</name><operator>.</operator><name>call_vector</name></name><argument_list>(<argument><expr><name>uargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// fast wrap for normal case where operator just returns a tensor.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>THPVariable_Unpack</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result_levels</name></expr></argument>, <argument><expr><name>device_holding_tensor</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>wrap</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
                <return>return <expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>THPVariable_Unpack</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result_levels</name></expr></argument>, <argument><expr><name>device_holding_tensor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>h</name></expr>;</return>
        </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>tree_map</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>wrap</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// std::cout &lt;&lt; orig &lt;&lt; " calling functorch...\n";</comment>
        <comment type="line">// std::cout &lt;&lt; "rl: " &lt;&lt; result_levels &lt;&lt; "\n";</comment>
        <decl_stmt><decl><type><name>EnableAllLayers</name></type> <name>guard</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>result_levels</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>flat_args</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>infos</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>TensorRef</name></type> <name>batched</name> <init>= <expr><name><name>infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>batchedtensor</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>device_holding_tensor</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>has_device</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>batched</name> <operator>=</operator> <call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>batched</name><operator>-&gt;</operator><name>to</name></name><argument_list>(<argument><expr><call><name><name>device_holding_tensor</name><operator>-&gt;</operator><name>device</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>guard</name><operator>.</operator><name>inplace_update_layers</name></name><argument_list>(<argument><expr><name>batched</name></expr></argument>, <argument><expr><name><name>infos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>levels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>flat_args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>handle_from_tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>batched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>flat_it</name> <init>= <expr><name>flat_args</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>uargs</name> <init>= <expr><call><name>unflatten_args</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>flat_it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>flat_it</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>result</name> <init>= <expr><call><name><name>orig</name><operator>.</operator><name>call_vector</name></name><argument_list>(<argument><expr><name>uargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>wrap</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>guard</name><operator>.</operator><name>from_batched</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>THPVariable_Unpack</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>device_holding_tensor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>h</name></expr>;</return>
        </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>guard</name><operator>.</operator><name>from_batched</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>THPVariable_Unpack</name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>device_holding_tensor</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name>tree_map</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>wrap</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>__torch_function__</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_pointwise</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>orig</name> <operator>==</operator> <name>torch_Tensor___mul__</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>nargs</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>args</name><operator>.</operator><name>has_keywords</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>lhs</name> <init>= <expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>rhs</name> <init>= <expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>isinstance</name></name><argument_list>(<argument><expr><name>lhs</name></expr></argument>, <argument><expr><name>_Tensor</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>py</name><operator>::</operator><name>isinstance</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>_Tensor</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>_Tensor_ndim</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>_Tensor_ndim</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>has_device</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>args</name><operator>.</operator><name>enumerate_positional</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>t</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// something like a mask * rhs, which matrix multiplies don't correctly promote</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>t</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>is_floating_point</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <return>return <expr><call><name>run_torch_function</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>is_pointwise</name></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>has_device</name> <operator>=</operator> <name>has_device</name> <operator>||</operator> <name><name>t</name><operator>.</operator><name>has_device</name></name></expr>;</expr_stmt>
                <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name><name>t</name><operator>.</operator><name>levels</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name><name>levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></for>
            <comment type="line">// std::cout &lt;&lt; "__torch_function__ " &lt;&lt; "delay" &lt;&lt; " " &lt;&lt; orig &lt;&lt; "\n";</comment>
            <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>create_delayed</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>, <argument><expr><name>has_device</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>run_torch_function</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>is_pointwise</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>as_vector_args</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>kwargs</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>pos_args</name> <init>= <expr><operator>(</operator><name><name>py</name><operator>::</operator><name>handle</name></name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><call><name><name>args</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>pos_n</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><call><name><name>args</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>kwargs</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>vector_args</name></name><argument_list>(<argument><expr><name>pos_args</name></expr></argument>, <argument><expr><name>pos_n</name></expr></argument>, <argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>all_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>kwnames</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>all_args</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>pos_args</name></expr></argument>, <argument><expr><name>pos_args</name> <operator>+</operator> <name>pos_n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>dict_view</name></name></type> <name>dv</name><argument_list>(<argument><expr><name>kwargs</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><call><name><name>dv</name><operator>.</operator><name>next</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>all_args</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>kwnames</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><call><name><name>py</name><operator>::</operator><name>vector_args</name></name><argument_list>(<argument><expr><call><name><name>all_args</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pos_n</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name>slice_to_tuple</name><argument_list>(<argument><expr><name>kwnames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>py___torch_function__</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>maybeInitializeGlobals</name><argument_list>()</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">4</literal> <operator>||</operator> <name>nargs</name> <operator>==</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>va</name> <init>= <expr><call><name>as_vector_args</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>nargs</name> <operator>==</operator> <literal type="number">5</literal></expr> ?</condition><then> <expr><name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr> </then><else>: <expr><literal type="null">nullptr</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_pointwise</name> <init>= <expr><call><name><name>pointwise</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>__torch_function__</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>is_pointwise</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>levels_to_tuple</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>slice</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>t</name><argument_list>(<argument><expr><call><name><name>slice</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>slice</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>t</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>slice</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>is_positional</name><argument_list>()</argument_list></call></expr> ?</condition><then>  <expr><call><name><name>py</name><operator>::</operator><name>from_int</name></name><argument_list>(<argument><expr><name><name>slice</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>position</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name><name>slice</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>dim</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>r</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PyObject</name><modifier>*</modifier></type> <name>Tensor_ndim</name><parameter_list>(<parameter><decl><type><name>Tensor</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><call><name><name>self</name><operator>-&gt;</operator><name>levels</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>py</name><operator>::</operator><name>from_int</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>Tensor_getsetters</name><index>[]</index></name> <init>= <expr><block>{
   <expr><block>{<expr><literal type="string">"_has_device"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> -&gt; <type><name>PyObject</name><modifier>*</modifier></type> <block>{<block_content> <return>return <expr><call><name><name>py</name><operator>::</operator><name>from_bool</name></name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Tensor</name><operator>*</operator><operator>)</operator><name>self</name><operator>)</operator><operator>-&gt;</operator><call><name>has_device</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return> <expr_stmt/>}</block_content></block></lambda></expr>, <expr><name>NULL</name></expr>}</block></expr>,
   <expr><block>{<expr><literal type="string">"_tensor"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> -&gt; <type><name>PyObject</name><modifier>*</modifier></type> <block>{<block_content>
       <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
       <return>return <expr><call><name>THPVariable_Wrap</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Tensor</name><operator>*</operator><operator>)</operator><name>self</name><operator>)</operator><operator>-&gt;</operator><call><name>tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> <expr_stmt/>}</block_content></block></lambda></expr>, <expr><name>NULL</name></expr>}</block></expr>,
   <expr><block>{<expr><literal type="string">"_batchtensor"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> -&gt; <type><name>PyObject</name><modifier>*</modifier></type> <block>{<block_content>
       <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
       <return>return <expr><call><name>THPVariable_Wrap</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Tensor</name><operator>*</operator><operator>)</operator><name>self</name><operator>)</operator><operator>-&gt;</operator><call><name>batchtensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> <expr_stmt/>}</block_content></block></lambda></expr>, <expr><name>NULL</name></expr>}</block></expr>,
   <expr><block>{<expr><literal type="string">"_levels"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <lambda><capture>[]</capture><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> -&gt; <type><name>PyObject</name><modifier>*</modifier></type> <block>{<block_content>
       <macro><name>PY_BEGIN</name></macro>
       <return>return <expr><call><name>levels_to_tuple</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Tensor</name><operator>*</operator><operator>)</operator><name>self</name><operator>)</operator><operator>-&gt;</operator><call><name>levels</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
       <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
   <expr_stmt/>}</block_content>}</block></lambda></expr>,
    <expr><block>{<expr><literal type="string">"ndim"</literal></expr>, <expr><operator>(</operator><name>getter</name><operator>)</operator> <name>Tensor_ndim</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="string">"ndim"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>  <comment type="block">/* Sentinel */</comment>
}</block></expr>;

<expr><specifier>static</specifier> <name>PyMethodDef</name> <name><name>Tensor_methods</name><index>[]</index></name> <operator>=</operator> <block>{
    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>        <comment type="block">/* Sentinel */</comment>
}</block></expr>;


<expr><name>PyTypeObject</name> <name><name>Tensor</name><operator>::</operator><name>Type</name></name> <operator>=</operator> <block>{
    <expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
    <literal type="string">"_C.Tensor"</literal></expr>,               <comment type="block">/* tp_name */</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tensor</name></expr></argument>)</argument_list></sizeof></expr>,               <comment type="block">/* tp_basicsize */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_itemsize */</comment>
    <expr><name><name>Tensor</name><operator>::</operator><name>dealloc_stub</name></name></expr>,      <comment type="block">/* tp_dealloc */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_vectorcall_offset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_getattr */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_setattr */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_async */</comment>
    <expr><literal type="number">0</literal></expr>,           <comment type="block">/* tp_repr */</comment>
    <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* tp_as_number */</comment>
    <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* tp_as_sequence */</comment>
    <expr><literal type="number">0</literal></expr>,             <comment type="block">/* tp_as_mapping */</comment>
    <expr><literal type="number">0</literal></expr>,      <comment type="block">/* tp_hash */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_call */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_str */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_getattro */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_setattro */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_buffer */</comment>
    <expr><name>Py_TPFLAGS_DEFAULT</name> <operator>|</operator> <name>Py_TPFLAGS_BASETYPE</name></expr> , <comment type="block">/* tp_flags */</comment>
    <expr><literal type="string">"Tensor Object"</literal></expr>,                   <comment type="block">/* tp_doc */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_traverse */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_clear */</comment>
    <expr><literal type="number">0</literal></expr>,  <comment type="block">/* tp_richcompare */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_weaklistoffset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_iter */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_iternext */</comment>
    <expr><name>Tensor_methods</name></expr>,                <comment type="block">/* tp_methods */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_members */</comment>
    <expr><name>Tensor_getsetters</name></expr>,             <comment type="block">/* tp_getset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_base */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_dict */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_descr_get */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_descr_set */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_dictoffset */</comment>
    <expr><literal type="number">0</literal></expr>,            <comment type="block">/* tp_init */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_alloc */</comment>
    <expr><name><name>Tensor</name><operator>::</operator><name>new_stub</name></name></expr>,                      <comment type="block">/* tp_new */</comment>
}</block></expr>;


<comment type="line">// dim() --------------------</comment>

<expr><name>bool</name> <macro><name>relevant_op</name><argument_list>(<argument>_Py_CODEUNIT c</argument>)</argument_list></macro> <block>{
    <switch>switch<condition>(<expr><call><name>_Py_OPCODE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><block>{
        <case>case <expr><name>STORE_NAME</name></expr>:</case>
        <case>case <expr><name>STORE_GLOBAL</name></expr>:</case>
        <case>case <expr><name>STORE_FAST</name></expr>:</case>
        <case>case <expr><name>STORE_DEREF</name></expr>:</case>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return></block></expr></expr_stmt></switch>
        <default>default:</default>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    }</block>
}

<name><name>py</name><operator>::</operator><name>object</name></name> <macro><name>getname</name><argument_list>(<argument>PyCodeObject* code</argument>, <argument>_Py_CODEUNIT c</argument>)</argument_list></macro> <block>{
    <expr><name>PyObject</name><operator>*</operator> <name>names</name> <operator>=</operator> <name>NULL</name></expr>;
    <switch>switch<condition>(<expr><call><name>_Py_OPCODE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <expr_stmt><expr><block>{
        <case>case <expr><name>STORE_NAME</name></expr>:</case>
        <case>case <expr><name>STORE_GLOBAL</name></expr>:</case>
          <expr><name>names</name> <operator>=</operator> <name><name>code</name><operator>-&gt;</operator><name>co_names</name></name></expr>;
          <break>break;</break></block></expr></expr_stmt></switch>
        <case>case <expr><name>STORE_FAST</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> <operator>&lt;</operator> <literal type="number">0x030b0000</literal></expr></cpp:if>
          <expr><name>names</name> <operator>=</operator> <name><name>code</name><operator>-&gt;</operator><name>co_varnames</name></name></expr>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr><name>names</name> <operator>=</operator> <call><name>PyCode_GetVarnames</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <break>break;</break></block></expr>
        <case>case <expr><name>STORE_DEREF</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> <operator>&lt;</operator> <literal type="number">0x030b0000</literal></expr></cpp:if>
          <expr><name>names</name> <operator>=</operator> <name><name>code</name><operator>-&gt;</operator><name>co_cellvars</name></name></expr>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr><name>names</name> <operator>=</operator> <call><name>PyCode_GetCellvars</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <break>break;</break></block></expr></init></decl></decl_stmt>
        <default>default:</default>
            <return>return <expr><call><name><name>py</name><operator>::</operator><name>object</name></name><argument_list>()</argument_list></call></expr>;</return>
    }
    return <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>steal</name></name><argument_list>(<argument><expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><call><name>_Py_OPARG</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

py<function><type><name><operator>::</operator><name>object</name></name></type> <name>create_dim</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>d</name><operator>-&gt;</operator><name>set_size</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>create_dimlist</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>DimList</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_int</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>d</name><operator>-&gt;</operator><name>bind_len</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>s</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>d</name><operator>-&gt;</operator><name>bind_len</name></name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><call><name><name>d</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dims_</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>set_size</name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<comment type="line">// Python wrappers that make new reflection primitives available for older runtimes</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> <operator>&lt;</operator> <literal type="number">0x030b0000</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyCode_CODE</name><parameter_list>(<parameter><type><name>CO</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_Py_CODEUNIT*)PyBytes_AS_STRING((CO)-&gt;co_code))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<template>template<parameter_list>&lt;<parameter><type><name><name>py</name><operator>::</operator><name>object</name></name></type> (*create_object</parameter>)</parameter_list>(<parameter><type><name><name>py</name><operator>::</operator><name>object</name></name></type></parameter><operator>,</operator> <parameter><type><name><name>py</name><operator>::</operator><name>handle</name></name></type>)</parameter>&gt;
<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>_dims</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <name>Py_ssize_t</name></type> <name>specified_ndims</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>found_ndims</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sizes</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>n</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>py_sizes</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>||</operator> <name>kwnames</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>va</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>va</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"dims"</literal></expr></argument>, <block>{<block_content><expr><literal type="string">"n"</literal></expr><operator>,</operator> <expr><literal type="string">"sizes"</literal></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <block>{<block_content><expr><operator>&amp;</operator><name>n</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>py_sizes</name></expr></block_content>}</block><operator>,</operator> <expr_stmt><expr><literal type="number">0</literal></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>py_sizes</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>sizes</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>sequence_view</name></name><argument_list>(<argument><expr><name>py_sizes</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>specified_ndims</name> <operator>=</operator> <name>sizes</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>specified_ndims</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></function></template>

    <decl_stmt><decl><type><name>PyThreadState</name><modifier>*</modifier></type> <name>state</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>f</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>PyFrameObject</name></expr></argument>&gt;</argument_list><operator>::</operator><name>steal</name></name><argument_list>(<argument><expr><call><name>PyThreadState_GetFrame</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>c</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>PyCodeObject</name></expr></argument>&gt;</argument_list><operator>::</operator><name>steal</name></name><argument_list>(<argument><expr><call><name>PyFrame_GetCode</name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>code</name> <init>= <expr><call><name>_PyCode_CODE</name><argument_list>(<argument><expr><call><name><name>c</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> <operator>&gt;=</operator> <literal type="number">0x030a00f0</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><call><name>PyFrame_GetLasti</name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><call><name>PyFrame_GetLasti</name><argument_list>(<argument><expr><call><name><name>f</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>/</operator>  <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>auto</name></type> <name>unpack</name> <init>= <expr><name><name>code</name><index>[<expr><name>first</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>names_start</name> <init>= <expr><name>first</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>relevant_op</name><argument_list>(<argument><expr><name>unpack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>found_ndims</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>_Py_OPCODE</name><argument_list>(<argument><expr><name>unpack</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UNPACK_SEQUENCE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>found_ndims</name> <operator>=</operator> <call><name>_Py_OPARG</name><argument_list>(<argument><expr><name>unpack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>names_start</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>specified_ndims</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>found_ndims</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_SyntaxError</name></expr></argument>, <argument><expr><literal type="string">"dims() must be assigned to a sequence of variable names or have argument n specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>specified_ndims</name> <operator>=</operator> <name>found_ndims</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>found_ndims</name> <operator>!=</operator> <name>specified_ndims</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>found_ndims</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// avoid taking the wrong names for dimensions</comment>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>genobject</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> -&gt; <type><name><name>py</name><operator>::</operator><name>object</name></name></type> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>found_ndims</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getname</name><argument_list>(<argument><expr><call><name><name>c</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><name>names_start</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>name</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>unicode_from_format</name></name><argument_list>(<argument><expr><literal type="string">"d%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>found_ndims</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="line">// once we fail at finding a name, we can find any more</comment>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name>create_object</name><argument_list>(<argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>sizes</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><call><name><name>py</name><operator>::</operator><name>sequence_view</name></name><argument_list>(<argument><expr><name>py_sizes</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr> </then><else>: <expr><call><name><name>py</name><operator>::</operator><name>handle</name></name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>sizes</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>sizes</name> <operator>!=</operator> <name>specified_ndims</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"expected %d sizes but found %d"</literal></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>specified_ndims</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>sizes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>specified_ndims</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>genobject</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <function_decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>result</name><parameter_list>(<parameter><decl><type><name>specified_ndims</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>specified_ndims</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>genobject</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>result</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
}

int64_t <macro><name>dim_index</name><argument_list>(<argument>const std::vector&lt;py::obj&lt;Dim&gt;&gt;&amp; dims</argument>, <argument>py::hdl&lt;Dim&gt; dim</argument>)</argument_list></macro> <block>{<block_content>
    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name>  <init>= <expr><call><name><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><name>i</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block>


<struct>struct <name>DotPart</name> <block>{<public type="default">
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>dims</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>total_size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <function><type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>total_size</name> <operator>*=</operator> <call><name><name>d</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>dims</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>
</public>}</block>;</struct>

<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<type><specifier>static</specifier> <name><name>at</name><operator>::</operator><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>as_array_ref</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>at</name><operator>::</operator><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>t</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>t</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>TensorRef</name></type> <name>dot_prepare</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>initializer_list</name><argument_list type="generic">&lt;<argument><expr><name>DotPart</name></expr></argument>&gt;</argument_list></name></type> <name>parts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TensorInfo</name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>new_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>needs_reshape</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>p</name> <range>: <expr><name>parts</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>p</name><operator>.</operator><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>needs_reshape</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>dims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>auto</name></type> <name>r</name> <init>= <expr><call><name>_match_levels</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>tensor</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>levels</name></name></expr></argument>, <argument><expr><name>new_levels</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>needs_reshape</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>r</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>view</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>p</name> <range>: <expr><name>parts</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>total_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>r</name><operator>-&gt;</operator><name>reshape</name></name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>view</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>view</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>dot_finish</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>initializer_list</name><argument_list type="generic">&lt;<argument><expr><name>DotPart</name></expr></argument>&gt;</argument_list></name></type> <name>parts</name></decl></parameter>, <parameter><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>result_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>needs_reshape</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>p</name> <range>: <expr><name>parts</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>p</name><operator>.</operator><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>needs_reshape</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>result_levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>dims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>needs_reshape</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>new_size</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name>result_levels</name></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>new_size</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>r</name><operator>.</operator><name>reshape</name></name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>new_size</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>new_size</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result_levels</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>dot</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>TensorInfo</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>TensorInfo</name></type> <name>rhs</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>sum</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>lhs_strides</name> <init>= <expr><call><name><name>lhs</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>strides</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>rhs_strides</name> <init>= <expr><call><name><name>rhs</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>strides</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>DotPart</name></type> <name>lro_dims</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DotPart</name></type> <name>lo_dims</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DotPart</name></type> <name>ro_dims</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DotPart</name></type> <name>lr_dims</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>insert_dim</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture> <parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name><name>at</name><operator>::</operator><name>optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>lhs_idx</name></decl></parameter>, <parameter><decl><type><name><name>at</name><operator>::</operator><name>optional</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>rhs_idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>reduced</name> <init>= <expr><call><name><name>sum</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>lhs_stride</name> <init>= <expr><ternary><condition><expr><name>lhs_idx</name></expr> ?</condition><then> <expr><name><name>lhs_strides</name><index>[<expr><operator>*</operator><name>lhs_idx</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int64_t</name></type> <name>rhs_stride</name> <init>= <expr><ternary><condition><expr><name>rhs_idx</name></expr> ?</condition><then> <expr><name><name>rhs_strides</name><index>[<expr><operator>*</operator><name>rhs_idx</name></expr>]</index></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>reduced</name></expr>)</condition> <block>{<block_content>
            <comment type="line">// lr</comment>
            <expr_stmt><expr><call><name><name>lr_dims</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lhs_stride</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>rhs_stride</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
                <comment type="line">// lro</comment>
                <expr_stmt><expr><call><name><name>lro_dims</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lhs_stride</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// lo</comment>
                <expr_stmt><expr><call><name><name>lo_dims</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>rhs_stride</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ro_dims</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>


    <decl_stmt><decl><type><name>auto</name></type> <name>rhs_seen</name> <init>= <expr><call><name><name>A</name><operator>.</operator><name>allocate</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>rhs</name><operator>.</operator><name>levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>fill</name></name><argument_list>(<argument><expr><name>rhs_seen</name></expr></argument>, <argument><expr><name>rhs_seen</name> <operator>+</operator> <call><name><name>rhs</name><operator>.</operator><name>levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>lhs</name><operator>.</operator><name>levels</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><name><name>lhs</name><operator>.</operator><name>levels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>rhs_idx</name> <init>= <expr><call><name><name>rhs</name><operator>.</operator><name>levels</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>rhs_idx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>rhs_seen</name><index>[<expr><operator>*</operator><name>rhs_idx</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>insert_dim</name><argument_list>(<argument><expr><call><name><name>d</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rhs_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>rhs</name><operator>.</operator><name>levels</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>rhs_seen</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><name><name>rhs</name><operator>.</operator><name>levels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>insert_dim</name><argument_list>(<argument><expr><call><name><name>d</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>at</name><operator>::</operator><name>nullopt</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><call><name><name>lr_dims</name><operator>.</operator><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>sum</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><expr><name>auto</name> <operator>&amp;</operator> <name>d</name> <operator>:</operator> <name>sum</name></expr></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>lhs</name><operator>.</operator><name>levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>rhs</name><operator>.</operator><name>levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"summing over non-existant dimension %S"</literal></expr></argument>, <argument><expr><call><name><name>d</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// std::cout &lt;&lt; lhs.levels &lt;&lt; " " &lt;&lt; rhs.levels &lt;&lt; " " &lt;&lt; sum &lt;&lt; "\n";</comment>
    <comment type="line">// std::cout &lt;&lt; lro_dims.dims &lt;&lt; " " &lt;&lt; lo_dims.dims &lt;&lt; " " &lt;&lt; ro_dims.dims &lt;&lt; " " &lt;&lt; lr_dims.dims &lt;&lt; "\n";</comment>

    <comment type="line">// no batch, just call mm</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>lro_dims</name><operator>.</operator><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>lhs_</name> <init>= <expr><call><name>dot_prepare</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><block>{<expr><name>lro_dims</name></expr>, <expr><name>lo_dims</name></expr>, <expr><name>lr_dims</name></expr>}</block></expr></argument>, <argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>rhs_</name> <init>= <expr><call><name>dot_prepare</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><block>{<expr><name>lro_dims</name></expr>, <expr><name>lr_dims</name></expr>, <expr><name>ro_dims</name></expr>}</block></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>dot_finish</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <block>{<block_content><expr><name>lro_dims</name></expr><operator>,</operator> <expr><name>lo_dims</name></expr><operator>,</operator> <expr><name>ro_dims</name></expr></block_content>}</block></argument_list></call></expr></return><operator>,</operator> <expr_stmt><expr><call><name><name>at</name><operator>::</operator><name>bmm</name></name><argument_list>(<argument><expr><operator>*</operator><name>lhs_</name></expr></argument>, <argument><expr><operator>*</operator><name>rhs_</name></expr></argument>)</argument_list></call></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt>
    </block_content>}</block></function> <if_stmt><else>else <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>lhs_</name> <init>= <expr><call><name>dot_prepare</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><block>{<expr><name>lo_dims</name></expr>, <expr><name>lr_dims</name></expr>}</block></expr></argument>, <argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>rhs_</name> <init>= <expr><call><name>dot_prepare</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><block>{<expr><name>lr_dims</name></expr>, <expr><name>ro_dims</name></expr>}</block></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>dot_finish</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <block>{<block_content><expr><name>lo_dims</name></expr><operator>,</operator> <expr><name>ro_dims</name></expr></block_content>}</block></argument_list></call></expr></return><operator>,</operator> <expr_stmt><expr><call><name><name>at</name><operator>::</operator><name>mm</name></name><argument_list>(<argument><expr><operator>*</operator><name>lhs_</name></expr></argument>, <argument><expr><operator>*</operator><name>rhs_</name></expr></argument>)</argument_list></call></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt></else></if_stmt>
    }

}

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>test_c</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>

    <name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>s</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>s</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name><name>s</name><operator>.</operator><name>capacity</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name><name>s</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator> <call><name><name>s</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">14</literal> <operator>&amp;&amp;</operator> <call><name><name>s</name><operator>.</operator><name>capacity</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>s2</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>s2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>ss</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>ss</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>ss</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>ss</name><operator>.</operator><name>capacity</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>ss</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>ss</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>ss</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ss</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">3</literal>  <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>sz</name> <init>= <expr><call><name><name>s</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>s</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>sz</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name><name>s</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>d</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>b</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>b</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>b</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>b</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><call><name><name>b</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PY_END</name><argument_list>(<argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>DimEntry</name></type> <name>_wrap_dim</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepdim</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>order</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <macro><name>PY_BEGIN</name></macro>
    <if_stmt><if>if <condition>(<expr><name>kwnames</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"unexpected keyword arguments %S"</literal></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><name>nargs</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>orig_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TensorRef</name></type> <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>self</name> <init>= <expr><name>args</name><operator>++</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_device</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>Tensor</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>t</name> <init>= <expr><call><name><name>Tensor</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>orig_levels</name> <operator>=</operator> <call><name><name>t</name><operator>-&gt;</operator><name>levels</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name><name>t</name><operator>-&gt;</operator><name>tensor</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>has_device</name> <operator>=</operator> <call><name><name>t</name><operator>-&gt;</operator><name>has_device</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
       <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>orig_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name><name>d</name><operator>-&gt;</operator><name>range</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>has_device</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>flat_positional_dims</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>std</name><operator>::</operator><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>to_flatten</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>orig_levels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>orig_ndim</name> <init>= <expr><call><name>ndim_of_levels</name><argument_list>(<argument><expr><name>levels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>append</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>DimEntry</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>midx</name> <init>= <expr><call><name><name>levels</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>midx</name></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>d</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"tensor has %d positional dimensions, but %d specified, or it was specified twice"</literal></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>orig_ndim</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><call><name><name>d</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>orig_ndim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"tensor of dimensions %R does not contain dim %R or it was specified twice"</literal></expr></argument>, <argument><expr><call><name>levels_to_tuple</name><argument_list>(<argument><expr><name>orig_levels</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>d</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>levels</name><index>[<expr><operator>*</operator><name>midx</name></expr>]</index></name> <operator>=</operator> <call><name>DimEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>flat_positional_dims</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>n_new_positional</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>:<expr><call><name>irange</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>arg</name>  <init>= <expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DimEntry</name></type> <name>entry</name> <init>= <expr><call><name>_wrap_dim</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>orig_ndim</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>entry</name><operator>.</operator><name>is_none</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>n_new_positional</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>DimList</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>dl</name> <init>= <expr><call><name><name>DimList</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name><name>py</name><operator>::</operator><name>obj</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type> <name>d</name> <range>: <expr><name><name>dl</name><operator>-&gt;</operator><name>dims_</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>++</operator><name>n_new_positional</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>n_new_positional</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_sequence</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"expected a Dim, List[Dim], or Sequence[Dim]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>sq</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>auto</name></type> <name>N</name> <init>= <expr><call><name><name>sq</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>to_flatten</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>make_pair</name></name><argument_list>(<argument><expr><call><name><name>flat_positional_dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>j</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>DimEntry</name></type> <name>e</name> <init>= <expr><call><name>_wrap_dim</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><name><name>sq</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>orig_ndim</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name><name>e</name><operator>.</operator><name>is_none</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"expected a Dim, or int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>append</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <decl_stmt><decl><type><name>int</name></type> <name>ndim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>insert_point</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>new_levels</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name>levels</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>l</name><operator>.</operator><name>is_none</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>ndim</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>insert_point</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>insert_point</name> <operator>=</operator> <call><name><name>new_levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>flat_positional_dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>insert_point</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>insert_point</name> <operator>=</operator> <call><name><name>new_levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>flat_positional_dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>ndata</name> <init>= <expr><operator>*</operator><call><name>_match_levels</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>orig_levels</name></expr></argument>, <argument><expr><name>new_levels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>to_flatten</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>view</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>sz</name> <init>= <expr><call><name><name>ndata</name><operator>.</operator><name>sizes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// before the new positional dims</comment>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>insert_point</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sz</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>to_flat</name> <range>: <expr><name>to_flatten</name></expr></range></decl></init>)</control> <block>{<block_content>
            <for>for <control>(<init>;</init><condition><expr><name>i</name> <operator>&lt;</operator> <name><name>to_flat</name><operator>.</operator><name>first</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sz</name><index>[<expr><name>insert_point</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>new_size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><name>i</name> <operator>+</operator> <name><name>to_flat</name><operator>.</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>last</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
                <expr_stmt><expr><name>new_size</name> <operator>*=</operator> <name><name>sz</name><index>[<expr><name>insert_point</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>flat_positional_dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sz</name><index>[<expr><name>insert_point</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="line">// after the new positional dims</comment>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>insert_point</name> <operator>+</operator> <call><name><name>flat_positional_dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>view</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sz</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <comment type="line">// we shorted the number of dimension, so remove them from new levels</comment>
        <comment type="line">// we will renumber them later</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>n_to_remove</name> <init>= <expr><call><name><name>flat_positional_dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <name>n_new_positional</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>new_levels</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><name>insert_point</name></expr></argument>, <argument><expr><name>insert_point</name> <operator>+</operator> <name>n_to_remove</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ndata</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>ndata</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>reshape</name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>view</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>view</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// renumber the positional dimension</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>seen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>new_levels</name><operator>.</operator><name>reversed_enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>new_levels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>is_positional</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><name>i</name> <operator>&gt;=</operator> <name>insert_point</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>insert_point</name> <operator>+</operator> <name>n_new_positional</name><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>new_levels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>--</operator><name>seen</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>ndata</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_levels</name></expr></argument>, <argument><expr><name>has_device</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>

    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>expand</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>AT_ASSERT</name><argument_list>(<argument><expr><name>nargs</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>info</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>args</name><operator>++</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Dim</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>maybeInitializeGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>vargs</name><argument_list>(<argument><expr><name>args</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>nargs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <return>return <expr><call><name><name>torch_Tensor_expand</name><operator>.</operator><name>call_vector</name></name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <return>return <expr><call><name>__torch_function__</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>torch_Tensor_expand</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><specifier>const</specifier> <name><name>at</name><operator>::</operator><name>Tensor</name></name><modifier>&amp;</modifier></type> <name>data</name> <init>= <expr><operator>*</operator><name><name>info</name><operator>.</operator><name>tensor</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>levels</name> <init>= <expr><name><name>info</name><operator>.</operator><name>levels</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>new_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>sz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>sd</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>new_levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"expanding dimension %R already exists in tensor with dims"</literal></expr></argument>, <argument><expr><call><name><name>d</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sz</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>d</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sd</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>levels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name></type> <name>osz</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>sizes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name></type> <name>osd</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>strides</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>sz</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>osz</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>osz</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>sd</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>osd</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>osd</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>ndata</name> <init>= <expr><call><name><name>data</name><operator>.</operator><name>as_strided</name></name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>sz</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sz</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>sd</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sd</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>data</name><operator>.</operator><name>storage_offset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>ndata</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_levels</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>has_device</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_bind_dims_to_size</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>sd</name></decl></parameter>,
                        <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>dims</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>nsz</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>nsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>rhs_prod</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>dims</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>is_bound</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>j</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dims</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><call><name>is_bound</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"cannot infer the sizes of two dimensions at once %R and %R"</literal></expr></argument>, <argument><expr><name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>dims</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>rhs_prod</name> <operator>*=</operator> <name><name>dims</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>%</operator> <name>rhs_prod</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>tup</name><argument_list>(<argument><expr><call><name><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>auto</name></type> <name>j</name> <range>: <expr><call><name><name>dims</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>tup</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>dims</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><call><name>is_bound</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>py</name><operator>::</operator><name>from_int</name></name><argument_list>(<argument><expr><name><name>dims</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>py</name><operator>::</operator><name>unicode_from_string</name></name><argument_list>(<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"inferred dimension does not evenly fit into larger dimension: %d vs %R"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>, <argument><expr><call><name><name>tup</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>int64_t</name></type> <name>inferred_size</name> <init>= <expr><name>sz</name> <operator>/</operator> <name>rhs_prod</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>set_size</name><argument_list>(<argument><expr><name>inferred_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rhs_prod</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rhs_prod</name> <operator>*=</operator> <name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>rhs_prod</name> <operator>!=</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>tup</name><argument_list>(<argument><expr><call><name><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>j</name> <range>: <expr><call><name><name>dims</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>tup</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name><name>dims</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Dimension sizes to do not match (%d != %d) when matching dimension pack %R"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>rhs_prod</name></expr></argument>, <argument><expr><call><name><name>tup</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>new_strides</name> <init>= <expr><call><name><name>A</name><operator>.</operator><name>allocate</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>dims</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>prev_stride</name> <init>= <expr><name>sd</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>dims</name><operator>.</operator><name>reversed_enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>new_strides</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>prev_stride</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev_stride</name> <operator>=</operator> <name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>size</name><argument_list>()</argument_list></call><operator>*</operator><name>prev_stride</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>dims</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>nsd</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>new_strides</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>nsz</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>dims</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>has_dims</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <return>return <expr><call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>Tensor</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>IndexingInfo</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>bool</name></type> <name>can_call_original</name></decl>;</decl_stmt> <comment type="line">// if true, then it is safe to just call getitem or setitem, these objects do not need special handling</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>advanced_indexing</name></decl>;</decl_stmt> <comment type="line">// requires actual lookup</comment>
    <decl_stmt><decl><type><name>TensorRef</name></type> <name>self</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>flat_inputs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>result_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_device</name></decl>;</decl_stmt>
</public>}</block>;</struct>

<function><type><specifier>static</specifier> <name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>as_slice</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>tuple_view</name></name></type> <name>tv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PyObject</name><modifier>*</modifier><modifier>*</modifier></type> <name>begin</name> <init>= <expr><operator>&amp;</operator><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><call><name><name>tv</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>(</operator><name><name>py</name><operator>::</operator><name>handle</name></name><operator>*</operator><operator>)</operator><name>begin</name></expr></argument>, <argument><expr><operator>(</operator><name><name>py</name><operator>::</operator><name>handle</name></name><operator>*</operator><operator>)</operator> <operator>(</operator><name>begin</name> <operator>+</operator> <call><name><name>tv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>as_slice</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>list_view</name></name></type> <name>tv</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PyObject</name><modifier>*</modifier><modifier>*</modifier></type> <name>begin</name> <init>= <expr><operator>&amp;</operator><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><call><name><name>tv</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>(</operator><name><name>py</name><operator>::</operator><name>handle</name></name><operator>*</operator><operator>)</operator><name>begin</name></expr></argument>, <argument><expr><operator>(</operator><name><name>py</name><operator>::</operator><name>handle</name></name><operator>*</operator><operator>)</operator> <operator>(</operator><name>begin</name> <operator>+</operator> <call><name><name>tv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>maybe_dimpack</name><parameter_list>(<parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>elements</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check_first</name><init>=<expr><literal type="boolean">true</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// can we avoid rechecking?</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>list_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>list_view</name></name></type> <name>tv</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>check_first</name> <operator>||</operator> <operator>(</operator><call><name><name>tv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name><name>tv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>elements</name> <operator>=</operator> <call><name>as_slice</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// can we avoid rechecking?</comment>
    <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple_view</name></name></type> <name>tv</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>check_first</name> <operator>||</operator> <operator>(</operator><call><name><name>tv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name><name>tv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>elements</name> <operator>=</operator> <call><name>as_slice</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function><empty_stmt>;</empty_stmt>

<function><type><name>bool</name></type> <name>is_dimpack</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>e</name></decl>;</decl_stmt>
    <return>return <expr><call><name>maybe_dimpack</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>IndexingInfo</name></type> <name>getsetitem_flat</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>TensorInfo</name></type> <name>self_info</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>input</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>keys</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_dimpacks_or_none</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>invoke_getitem</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexingInfo</name><modifier>&amp;</modifier></type> <name>iinfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>index</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>dims</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>maybeInitializeGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>dims_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>indices_list</name></decl>;</decl_stmt>
    <comment type="line">// we allow for matching single dims to multiple dims,</comment>
    <comment type="line">// so we first have to normalize everything into the case where there is a list on lhs and the rhs</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>lhs_list</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>py</name><operator>::</operator><name>list_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>rhs_list</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>py</name><operator>::</operator><name>list_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lhs_list</name> <operator>&amp;&amp;</operator> <name>rhs_list</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>dv</name><argument_list>(<argument><expr><name>dims</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>ind</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>N</name> <init>= <expr><call><name><name>dv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>N</name> <operator>!=</operator> <call><name><name>ind</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"dims (%d) and indices (%d) must have the same length"</literal></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><call><name><name>ind</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>dims_list</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><name><name>dv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>indices_list</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><name><name>ind</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>dims_list</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>indices_list</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// dims being indexed can be grouped together into a single index space, and we have to</comment>
    <comment type="line">// flatten them int a single dimension before we can index them...</comment>
    <decl_stmt><decl><type><name>auto</name></type> <name>self_info</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>ndim</name> <init>= <expr><call><name><name>self_info</name><operator>.</operator><name>ndim</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>new_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>to_flatten</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>dims_list_flat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>parse_dim_entry</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>s</name></decl></parameter>)</parameter_list> -&gt; <type><name>DimEntry</name></type> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name>_wrap_dim</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>d</name><operator>.</operator><name>is_none</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"expected a dimension specifyer but found %R"</literal></expr></argument>, <argument><expr><call><name><name>s</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>d</name></expr>;</return>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>dim_not_present</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>DimEntry</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>d</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"dimension %d not in tensor of %d dimensions"</literal></expr></argument>, <argument><expr><call><name><name>d</name><operator>.</operator><name>position</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>ndim</name></expr></argument> , <argument><expr><name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"dimension %R not in tensor"</literal></expr></argument>, <argument><expr><call><name><name>d</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>dims_list</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>m</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>maybe_dimpack</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>dims_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <comment type="block">/*check_first=*/</comment><argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <comment type="line">// plausible semantics work for this to have 0 elements (e.g. the index will always be 0)</comment>
                <expr_stmt><expr><call><name><name>dims_list_flat</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>DimEntry</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// value is just dropped</comment>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name>auto</name></type> <name>first</name> <init>= <expr><call><name>parse_dim_entry</name><argument_list>(<argument><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>dims_list_flat</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>to_flatten</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>self_info</name><operator>.</operator><name>levels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>rest</name></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>m</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name>parse_dim_entry</name><argument_list>(<argument><expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>new_levels</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>dim_not_present</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name><name>rest</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>

            <decl_stmt><decl><type><name>auto</name></type> <name>first_idx</name> <init>= <expr><call><name><name>new_levels</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_idx</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>dim_not_present</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>new_levels</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><operator>*</operator><name>first_idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>first_idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>to_flatten</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>dims_list_flat</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>parse_dim_entry</name><argument_list>(<argument><expr><name><name>dims_list</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><call><name><name>to_flatten</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>TensorRef</name></type> <name>rearranged</name> <init>= <expr><call><name>_match_levels</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>self_info</name><operator>.</operator><name>tensor</name></name></expr></argument>, <argument><expr><name><name>self_info</name><operator>.</operator><name>levels</name></name></expr></argument>, <argument><expr><name>new_levels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name></type> <name>sizes</name> <init>= <expr><call><name><name>rearranged</name><operator>-&gt;</operator><name>sizes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>new_sizes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>reshape_levels</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>new_levels</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>to_flatten</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name><name>new_levels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>new_sizes</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call> <operator>*=</operator> <name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><call><name><name>new_sizes</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>reshape_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>new_levels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>self_info</name><operator>.</operator><name>tensor</name></name> <operator>=</operator> <call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>rearranged</name><operator>-&gt;</operator><name>reshape</name></name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>new_sizes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>new_sizes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>self_info</name><operator>.</operator><name>levels</name></name> <operator>=</operator> <name>reshape_levels</name></expr>;</expr_stmt> <comment type="line">// note: we are using the first level in a flattened group to represent the group for the rest of the op</comment>
                                           <comment type="line">// we need to be careful not to rely the dimensions size because it doesnt match the size of the whole group</comment>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_dimpacks</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>idx</name> <range>: <expr><name>indices_list</name></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>py</name><operator>::</operator><name>list_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>has_dimpacks</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>IndexingInfo</name></type> <name>info</name> <init>= <expr><call><name>getsetitem_flat</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self_info</name></expr></argument>, <argument><expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>dims_list_flat</name></expr></argument>, <argument><expr><name>indices_list</name></expr></argument>, <argument><expr><name>has_dimpacks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>invoke_getitem</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// true -- the indices were flattend out of a tuple, list or sequence...</comment>

<function><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>slice_from_sequence</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>as_slice</name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>list_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name>as_slice</name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>list_view</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>sv</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>r</name></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>sv</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <return>return <expr><name>r</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>extractIndices</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>indices</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>as_slice</name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>tuple_view</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>index</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_sequence</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">false</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// a copy of treatSequenceAsTuple modified to add Dim and our wrapped tensors..</comment>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>sv</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>sv</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>slice_from_sequence</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="boolean">true</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>sv</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>item</name></decl>;</decl_stmt>
        <try>try <block>{<block_content>
            <expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>sv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block> <catch>catch <parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>exception_set</name></name> <modifier>&amp;</modifier></type> <name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
            <expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">false</literal></expr>;</return>
        </block_content>}</block></catch></try>
        <if_stmt><if>if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>item</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>py</name><operator>::</operator><name>is_sequence</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PySlice_Check</name><argument_list>(<argument><expr><call><name><name>item</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>item</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Py_Ellipsis</name> <operator>||</operator> <call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>has_dims</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>slice_from_sequence</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><literal type="boolean">true</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="boolean">false</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexingInfo</name></type> <name>getsetitem</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tensors_have_dims</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>can_call_original_getitem</name> <init>= <expr><operator>!</operator><name>tensors_have_dims</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>input</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>has_dims</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>input</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>is_sequence</name> <init>= <expr><call><name>extractIndices</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// nothing about first class dims here, fallback to getitem</comment>
        <if_stmt><if>if <condition>(<expr><name>can_call_original_getitem</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_sequence</name></expr>)</condition> <block>{<block_content>
            <return>return <expr><block>{ <expr><literal type="boolean">true</literal></expr> }</block></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>dims_indexed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>expanding_object</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DimList</name><modifier>*</modifier></type> <name>unbound_dim_list</name> <init>= <expr><literal type="null">nullptr</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>check_expanding</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>expanding_object</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"at most one ... or unbound dimension list can exist in indexing list but found 2 at offsets %d and %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>expanding_object</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>expanding_object</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>dimlists</name></decl>;</decl_stmt>

    <comment type="line">// calculate how many dimensioned have been indexed in order to compute the size of ...</comment>
    <comment type="line">// or expand a potentially unbound dimension list.</comment>

    <decl_stmt><decl><type><name>bool</name></type> <name>has_dimpacks_or_none</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>input</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>s</name> <init>= <expr><name><name>input</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>Tensor</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>can_call_original_getitem</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>dims_indexed</name></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>s</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Py_Ellipsis</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>check_expanding</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>DimList</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>can_call_original_getitem</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>auto</name></type> <name>dl</name> <init>= <expr><call><name><name>DimList</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dl</name><operator>-&gt;</operator><name>is_bound</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>check_expanding</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>unbound_dim_list</name> <operator>=</operator> <call><name><name>dl</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>dims_indexed</name> <operator>+=</operator> <call><name><name>dl</name><operator>-&gt;</operator><name>dims_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name><name>dimlists</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>has_dimpacks_or_none</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_dimpack</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>can_call_original_getitem</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>has_dimpacks_or_none</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>++</operator><name>dims_indexed</name></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>dims_indexed</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// at this point if we haven't seen any Dim objects, we also can fallback to the original getitem.</comment>
    <if_stmt><if>if <condition>(<expr><name>can_call_original_getitem</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><block>{<expr><literal type="boolean">true</literal></expr>}</block></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// std::cout &lt;&lt; "__getitem__ " &lt;&lt; self &lt;&lt; " " &lt;&lt; index &lt;&lt; "\n";</comment>

    <decl_stmt><decl><type><name>TensorInfo</name></type> <name>self_info</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>ndim</name> <init>= <expr><call><name><name>self_info</name><operator>.</operator><name>ndim</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>dims_indexed</name> <operator>&gt;</operator> <name>ndim</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"at least %d indices were supplied but the tensor only has %d dimensions"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>dims_indexed</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ndim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// expand any unbound dimension list, or expand ... into individual : slices.</comment>
    <decl_stmt><decl><type><name>auto</name></type> <name>expanding_dims</name> <init>= <expr><name>ndim</name> <operator>-</operator> <name>dims_indexed</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>expanding_object</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>unbound_dim_list</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>unbound_dim_list</name><operator>-&gt;</operator><name>bind_len</name></name><argument_list>(<argument><expr><name>expanding_dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <comment type="line">// ...</comment>
            <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>no_slices</name></decl>;</decl_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name>irange</name><argument_list>(<argument><expr><name>expanding_dims</name></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>no_slices</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>no_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name><name>input</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>input</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><name>expanding_object</name></expr></argument>, <argument><expr><name>expanding_object</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>no_slices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// flatten out any dimensions stored in dimlist elements directly into the inputs</comment>
    <comment type="line">// std::cout &lt;&lt; dimlists &lt;&lt; " &lt;- dim lists!\n";</comment>
    <for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><call><name><name>dimlists</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>idx</name> <init>= <expr><name><name>dimlists</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <comment type="line">// we added more elements to input because of ...</comment>
        <comment type="line">// so we need to also adjust the index to get back to where the</comment>
        <comment type="line">// dimlist existed</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>unbound_dim_list</name> <operator>&amp;&amp;</operator> <name>expanding_object</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&gt;</operator> <name>expanding_object</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>expanding_dims</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>dl</name> <init>= <expr><call><name><name>DimList</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name><name>input</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// XXX would be better if we used an OwnedSlice in DimList</comment>
        <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>more_dims</name><argument_list>(<argument><expr><operator>(</operator><name><name>py</name><operator>::</operator><name>handle</name></name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>*</operator><call><name><name>dl</name><operator>-&gt;</operator><name>dims_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name><name>py</name><operator>::</operator><name>handle</name></name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>*</operator><call><name><name>dl</name><operator>-&gt;</operator><name>dims_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>input</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>input</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>more_dims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><call><name>getsetitem_flat</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self_info</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>has_dimpacks_or_none</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>IndexingInfo</name></type> <name>getsetitem_flat</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>TensorInfo</name></type> <name>self_info</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>input</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>keys</name></decl></parameter>, <parameter><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>has_dimpacks_or_none</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <comment type="line">// At this point:</comment>
    <comment type="line">// ..., DimList have been eliminated</comment>
    <comment type="line">// Dim, Tensor, Tuple[Dim,...], int, slice still remain</comment>


    <comment type="line">// we have to count how many times we see a dimension.</comment>
    <comment type="line">// A[i,j] is a simple binding operation, but A[i, i+j] or A[i, i] requires advanced indexing.</comment>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>seen_dims</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>seen_dims_nuses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>add_dim</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></type> <name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>midx</name> <init>= <expr><call><name><name>seen_dims</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>midx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>seen_dims</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>seen_dims_nuses</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name><name>seen_dims_nuses</name><index>[<expr><operator>*</operator><name>midx</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>input_it</name> <init>= <expr><name>input</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>flat_inputs</name></decl>;</decl_stmt>
    <comment type="line">// flat inputs will start with an empty py::handle if the</comment>
    <comment type="line">// actual value is in the tensor-like object in the tensor info</comment>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>TensorInfo</name></expr></argument>&gt;</argument_list></name></type> <name>tensor_inputs</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>append_flat_handle</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>flat_inputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tensor_inputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>TensorInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TensorRef</name></type> <name>device_holding_tensor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>append_tensor_input</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>TensorInfo</name></type> <name>ti</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><call><name><name>flat_inputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>handle</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tensor_inputs</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ti</name><operator>.</operator><name>has_device</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>device_holding_tensor</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>device_holding_tensor</name> <operator>=</operator> <name><name>ti</name><operator>.</operator><name>tensor</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>nsz</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>nsd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name></type> <name>sz</name> <init>= <expr><call><name><name>self_info</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>sizes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name></type> <name>sd</name> <init>= <expr><call><name><name>self_info</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>strides</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>append_size</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>has_dimpacks_or_none</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>nsz</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sz</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>nsd</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <comment type="line">// std::cout &lt;&lt; "self levels: " &lt;&lt; self_info.levels &lt;&lt; "\n";</comment>

    <decl_stmt><decl><type><name>auto</name></type> <name>parse_nones</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>()</parameter_list> <block>{<block_content>
        <while>while <condition>(<expr><call><name><name>input_it</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name><name>input_it</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>append_flat_handle</name><argument_list>(<argument><expr><name>no_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>nsz</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>nsd</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>input_it</name> <operator>=</operator> <call><name><name>input_it</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>


    <decl_stmt><decl><type><name>auto</name></type> <name>append_item</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>d</name><operator>-&gt;</operator><name>set_size</name></name><argument_list>(<argument><expr><name><name>sz</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>add_dim</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>append_size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>append_flat_handle</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>info</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>info</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>append_size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>append_tensor_input</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><decl><type><name>auto</name></type> <name>il</name> <range>: <expr><name><name>info</name><operator>.</operator><name>levels</name></name></expr></range></decl></init>)</control> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>il</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name>add_dim</name><argument_list>(<argument><expr><call><name><name>il</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>has_dimpacks_or_none</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>mp</name></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>maybe_dimpack</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// dim pack</comment>
                <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>hdl</name><argument_list type="generic">&lt;<argument><expr><name>Dim</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>dim_pack</name></decl>;</decl_stmt>
                <for>for <control>(<init><decl><type><name>auto</name></type> <name>d</name> <range>: <expr><name>mp</name></expr></range></decl></init>)</control> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>dim_pack</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>Dim</name><operator>::</operator><name>wrap</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>add_dim</name><argument_list>(<argument><expr><call><name><name>dim_pack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>append_flat_handle</name><argument_list>(<argument><expr><call><name><name>dim_pack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>_bind_dims_to_size</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>sz</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>dim_pack</name></expr></argument>, <argument><expr><name>nsz</name></expr></argument>, <argument><expr><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>append_size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>append_flat_handle</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <comment type="line">// pair up the indexing expressions with dimension of self it indexes</comment>
    <comment type="line">// self may have first-class dims, which do not participate the indexing.</comment>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>self_info</name><operator>.</operator><name>levels</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>l</name> <init>= <expr><name><name>self_info</name><operator>.</operator><name>levels</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>idx</name> <init>= <expr><call><name><name>keys</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>idx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>append_item</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><operator>*</operator><name>idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <comment type="line">// grab and index from the positional list</comment>
            <expr_stmt><expr><call><name>parse_nones</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>input_it</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// we might have fewer indices than tensor dimensions,</comment>
                <comment type="line">// which implicitly indexes the remaining dimensions with :</comment>
                <expr_stmt><expr><call><name>append_flat_handle</name><argument_list>(<argument><expr><name>no_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>append_size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>arg</name> <init>= <expr><name><name>input_it</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>input_it</name> <operator>=</operator> <call><name><name>input_it</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>append_item</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>add_dim</name><argument_list>(<argument><expr><call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>append_flat_handle</name><argument_list>(<argument><expr><call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>append_size</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <comment type="line">// any training Nones may have no existing dimension associated with them in self.</comment>
    <expr_stmt><expr><call><name>parse_nones</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// we have to restride the tensor to collapse dimension packs and introduce our none dimensions.</comment>
    <if_stmt><if>if <condition>(<expr><name>has_dimpacks_or_none</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>self_info</name><operator>.</operator><name>tensor</name></name> <operator>=</operator> <call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>self_info</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>as_strided</name></name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>nsz</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>nsz</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>nsd</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>nsd</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>self_info</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>storage_offset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <comment type="line">// figure out what the shape of the indexing tensors will be</comment>
    <comment type="line">// and what the shape of the resulting tensor will be</comment>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>result_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>index_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>tensor_insert_point</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>requires_getindex</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>mark_tensor_index</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tensor_insert_point</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>tensor_insert_point</name> <operator>=</operator> <call><name><name>result_levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tensor_insert_point</name> <operator>!=</operator> <call><name><name>result_levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>tensor_insert_point</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>flat_inputs</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>inp</name> <init>= <expr><name><name>flat_inputs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
         <if_stmt><if>if<condition>(<expr><name><name>tensor_inputs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
             <expr_stmt><expr><name>requires_getindex</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>mark_tensor_index</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
             <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name><name>tensor_inputs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>levels</name></expr></range></decl></init>)</control> <block>{<block_content>
                 <comment type="line">// std::cout &lt;&lt; "Consider to add " &lt;&lt; l &lt;&lt; "\n";</comment>
                 <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>index_levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                     <expr_stmt><expr><call><name><name>index_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 </block_content>}</block></if></if_stmt>
             </block_content>}</block></for>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// dimesions used once are just binding operations</comment>
            <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <name><name>seen_dims_nuses</name><index>[<expr><operator>*</operator><call><name><name>seen_dims</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name><name>flat_inputs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>no_slice</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>result_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>requires_getindex</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>flat_inputs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>handle</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tensor_inputs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>TensorInfo</name> <argument_list>{<argument><expr><call><name><name>d</name><operator>-&gt;</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>DimEntry</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><macro><name>TensorRef</name><argument_list>()</argument_list></macro></expr></argument>}</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>index_levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                     <expr_stmt><expr><call><name><name>index_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>mark_tensor_index</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
         </block_content>}</block></if> <else>else <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name><name>inp</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>no_slice</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>requires_getindex</name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_int</name></name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <comment type="line">// note: actual positional indexes are accurately computed later</comment>
                <expr_stmt><expr><call><name><name>result_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
         </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="line">// indexing dimensions appear in the tensor at the _first use of a tensor_ in the indexing. So insert</comment>
    <comment type="line">// the indexing leveles into the result klevels at this spot</comment>
    <if_stmt><if>if <condition>(<expr><name>tensor_insert_point</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>result_levels</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>result_levels</name><operator>.</operator><name>slice</name></name><argument_list>(<argument><expr><name>tensor_insert_point</name></expr></argument>, <argument><expr><name>tensor_insert_point</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>index_levels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// std::cout &lt;&lt; "flat inputs: " &lt;&lt; flat_inputs &lt;&lt; "\n";</comment>
    <comment type="line">// std::cout &lt;&lt; "result_levels: " &lt;&lt; result_levels &lt;&lt; "\n";</comment>
    <comment type="line">// std::cout &lt;&lt; "index_levels: " &lt;&lt; index_levels &lt;&lt; "\n";</comment>

    <comment type="line">// get all the tensors to be the right shape for indexing</comment>
    <if_stmt><if>if <condition>(<expr><name>requires_getindex</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>flat_inputs</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>tensor_inputs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>AT_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>flat_inputs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// std::cout &lt;&lt; "tensor " &lt;&lt; i &lt;&lt; " " &lt;&lt; tensor_inputs[i].levels &lt;&lt; "\n";</comment>
                <decl_stmt><decl><type><name>TensorRef</name></type> <name>t</name> <init>= <expr><name><name>tensor_inputs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tensor</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tensor_inputs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>has_device</name> <operator>&amp;&amp;</operator> <name>device_holding_tensor</name></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>t</name><operator>-&gt;</operator><name>to</name></name><argument_list>(<argument><expr><call><name><name>device_holding_tensor</name><operator>-&gt;</operator><name>device</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>flat_inputs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>handle_from_tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>_match_levels</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>tensor_inputs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>levels</name></expr></argument>, <argument><expr><name>index_levels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// previously we didn't know how many positional dimensions there would be so we couldn't number them right</comment>
    <comment type="line">// so fill it in now.</comment>
    <decl_stmt><decl><type><name>auto</name></type> <name>seen_positionals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>result_levels</name><operator>.</operator><name>reversed_enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>result_levels</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>is_positional</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name><name>result_levels</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><operator>(</operator><operator>++</operator><name>seen_positionals</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><call><name>IndexingInfo</name> <argument_list>{<argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><name>requires_getindex</name></expr></argument>, <argument><expr><name><name>self_info</name><operator>.</operator><name>tensor</name></name></expr></argument>, <argument><expr><name>flat_inputs</name></expr></argument>, <argument><expr><name>result_levels</name></expr></argument>, <argument><expr><name><name>self_info</name><operator>.</operator><name>has_device</name></name></expr></argument>}</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>invoke_getitem</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexingInfo</name><modifier>&amp;</modifier></type> <name>iinfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name><name>at</name><operator>::</operator><name>Tensor</name></name></type> <name>rtensor</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>iinfo</name><operator>.</operator><name>advanced_indexing</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>self_hdl</name> <init>= <expr><call><name>handle_from_tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>iinfo</name><operator>.</operator><name>self</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>tup</name> <init>= <expr><call><name>slice_to_tuple</name><argument_list>(<argument><expr><name><name>iinfo</name><operator>.</operator><name>flat_inputs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// std::cout &lt;&lt; "calling original getindex " &lt;&lt; self_hdl &lt;&lt; " " &lt;&lt; tup &lt;&lt; "\n";</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>pytensor</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>checked_steal</name></name><argument_list>(<argument><expr><call><name>THPVariable_getitem</name><argument_list>(<argument><expr><call><name><name>self_hdl</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>tup</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rtensor</name> <operator>=</operator> <call><name>THPVariable_Unpack</name><argument_list>(<argument><expr><call><name><name>pytensor</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="line">// std::cout &lt;&lt; "skipping original getindex\n";</comment>
        <expr_stmt><expr><name>rtensor</name> <operator>=</operator> <operator>*</operator><name><name>iinfo</name><operator>.</operator><name>self</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="line">// std::cout &lt;&lt; "returning (from_positional)\n";</comment>
    <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>rtensor</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>iinfo</name><operator>.</operator><name>result_levels</name></name></expr></argument>, <argument><expr><name><name>iinfo</name><operator>.</operator><name>has_device</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>py</name><operator>::</operator><name>object</name></name></type> <name>__getitem__</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>maybeInitializeGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>iinfo</name> <init>= <expr><call><name>getsetitem</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>has_dims</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>iinfo</name><operator>.</operator><name>can_call_original</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>checked_steal</name></name><argument_list>(<argument><expr><call><name>THPVariable_getitem</name><argument_list>(<argument><expr><call><name><name>self</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>index</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>invoke_getitem</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>iinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>PyObject</name><modifier>*</modifier></type> <name>Tensor_getitem</name><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <macro><name>PY_BEGIN</name></macro>
    <return>return <expr><call><name>__getitem__</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <expr_stmt><expr><call><name>PY_END</name><argument_list>(<argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__setitem__</name><parameter_list>(<parameter><decl><type><name>Arena</name> <modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>rhs</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <expr_stmt><expr><call><name>maybeInitializeGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>iinfo</name> <init>= <expr><call><name>getsetitem</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>has_dims</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>has_dims</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>iinfo</name><operator>.</operator><name>can_call_original</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <call><name>THPVariable_setitem</name><argument_list>(<argument><expr><call><name><name>self</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>index</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>rhs</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>py</name><operator>::</operator><name>exception_set</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>rhs_info</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>rhs_info</name></expr>)</condition> <block>{<block_content> <comment type="line">// otherwise rhs can be a scalar...</comment>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><name><name>rhs_info</name><operator>.</operator><name>levels</name></name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>iinfo</name><operator>.</operator><name>result_levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name><name>l</name><operator>.</operator><name>is_positional</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
                    <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"rhs contains too many dimensions (%d) compared to indexed value (%d)"</literal></expr></argument>, <argument><expr><call><name>ndim_of_levels</name><argument_list>(<argument><expr><name><name>iinfo</name><operator>.</operator><name>result_levels</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>rhs_info</name><operator>.</operator><name>ndim</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if> <else>else <block>{<block_content>
                    <decl_stmt><decl><type><name>auto</name></type> <name>tup</name> <init>= <expr><call><name>levels_to_tuple</name><argument_list>(<argument><expr><name><name>iinfo</name><operator>.</operator><name>result_levels</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><call><name>DimensionBindError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"rhs of setitem contains dimension %R which is not in the dimension on the left (%R)"</literal></expr></argument>, <argument><expr><call><name><name>l</name><operator>.</operator><name>dim</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>tup</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <decl_stmt><decl><type><name>auto</name></type> <name>rhs_matched</name> <init>= <expr><call><name>_match_levels</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>rhs_info</name><operator>.</operator><name>tensor</name></name></expr></argument>, <argument><expr><name><name>rhs_info</name><operator>.</operator><name>levels</name></name></expr></argument>, <argument><expr><name><name>iinfo</name><operator>.</operator><name>result_levels</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rhs</name> <operator>=</operator> <call><name>handle_from_tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>rhs_matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>self</name> <operator>=</operator> <call><name>handle_from_tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>iinfo</name><operator>.</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>iinfo</name><operator>.</operator><name>advanced_indexing</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>tup</name> <init>= <expr><call><name>slice_to_tuple</name><argument_list>(<argument><expr><name><name>iinfo</name><operator>.</operator><name>flat_inputs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <call><name>THPVariable_setitem</name><argument_list>(<argument><expr><call><name><name>self</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>tup</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>rhs</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <throw>throw <expr><call><name><name>py</name><operator>::</operator><name>exception_set</name></name><argument_list>()</argument_list></call></expr>;</throw>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name><name>torch_Tensor_copy_</name><operator>.</operator><name>call</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>Tensor_setitem</name><parameter_list>(<parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>PyObject</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>__setitem__</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
    <expr_stmt><expr><call><name>PY_END</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>py___getitem__</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>AT_ASSERT</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <return>return <expr><call><name>__getitem__</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>py___setitem__</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>AT_ASSERT</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>__setitem__</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>py_index</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>va</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>self</name></decl>, <decl><type ref="prev"/><name>dims</name></decl>, <decl><type ref="prev"/><name>indices</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>va</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>, <block>{<block_content><expr><literal type="string">"self"</literal></expr><operator>,</operator> <expr><literal type="string">"dims"</literal></expr><operator>,</operator> <expr><literal type="string">"indices"</literal></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <block>{<block_content><expr><operator>&amp;</operator><name>self</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>dims</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>indices</name></expr></block_content>}</block><operator>,</operator> <expr_stmt><expr><literal type="number">3</literal></expr></expr_stmt>)</block_content></block>;</function>
    <return>return <expr><call><name>index</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>indices</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
}


static <function><type><name>PyObject</name><modifier>*</modifier></type> <name>py_stack</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>va</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>tensors</name></decl>, <decl><type ref="prev"/><name>new_dim</name></decl>, <decl><type ref="prev"/><name>dim</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>va</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"stack"</literal></expr></argument>, <block>{<block_content><expr><literal type="string">"tensors"</literal></expr><operator>,</operator> <expr><literal type="string">"new_dim"</literal></expr><operator>,</operator> <expr><literal type="string">"dim"</literal></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <block>{<block_content><expr><operator>&amp;</operator><name>tensors</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>new_dim</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>dim</name></expr></block_content>}</block><operator>,</operator> <expr_stmt><expr><literal type="number">2</literal></expr></expr_stmt>)</block_content></block>;</function>

    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>result_levels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>TensorInfo</name></expr></argument>&gt;</argument_list></name></type> <name>infos</name></decl>;</decl_stmt>
    <function_decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>sv</name><parameter_list>(<parameter><decl><type><name>tensors</name></type></decl></parameter>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>auto</name></type> <name>new_dim_d</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>wrap</name></name><argument_list>(<argument><expr><name>new_dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>sv</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>infos</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>l</name> <range>: <expr><call><name><name>infos</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>levels</name></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>result_levels</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>result_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name><name>new_dim_d</name><operator>-&gt;</operator><name>set_size</name></name><argument_list>(<argument><expr><call><name><name>infos</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>vector</name><argument_list type="generic">&lt;<argument><expr><name><name>at</name><operator>::</operator><name>Tensor</name></name></expr></argument>&gt;</argument_list></name></type> <name>inputs</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>inputs</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>infos</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>in</name> <range>: <expr><name>infos</name></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name><name>inputs</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><operator>*</operator><call><name>_match_levels</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>in</name><operator>.</operator><name>tensor</name></name></expr></argument>, <argument><expr><name><name>in</name><operator>.</operator><name>levels</name></name></expr></argument>, <argument><expr><name>result_levels</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>auto</name></type> <name>ndim</name> <init>= <expr><call><name>ndim_of_levels</name><argument_list>(<argument><expr><name>result_levels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>rawdim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name>_wrap_dim</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>idx</name> <init>= <expr><call><name><name>result_levels</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>idx</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"Dimension %R does not exist in inputs"</literal></expr></argument>, <argument><expr><call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>rawdim</name> <operator>=</operator> <operator>*</operator><name>idx</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>result</name> <init>= <expr><call><name><name>at</name><operator>::</operator><name>stack</name></name><argument_list>(<argument><expr><name>inputs</name></expr></argument>, <argument><expr><name>rawdim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>result_levels</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>rawdim</name></expr></argument>, <argument><expr><name>new_dim_d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result_levels</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
}

static <function><type><name>PyObject</name><modifier>*</modifier></type> <name>py_split</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>maybeInitializeGlobals</name><argument_list>()</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>va</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>self</name></decl>, <decl><type ref="prev"/><name>split_size_or_sections</name></decl>, <decl><type ref="prev"/><name>dim</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>va</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"split"</literal></expr></argument>, <block>{<block_content><expr><literal type="string">"self"</literal></expr><operator>,</operator> <expr><literal type="string">"split_size_or_sections"</literal></expr><operator>,</operator> <expr><literal type="string">"dim"</literal></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <block>{<block_content><expr><operator>&amp;</operator><name>self</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>split_size_or_sections</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>dim</name></expr></block_content>}</block><operator>,</operator> <expr_stmt><expr><literal type="number">2</literal></expr></expr_stmt>)</block_content></block>;</function>
    <decl_stmt><decl><type><name>bool</name></type> <name>dim_is_object</name> <init>= <expr><call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>sizes</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>all_dims</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>all_ints</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_int</name></name><argument_list>(<argument><expr><name>split_size_or_sections</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <function_decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>sv</name><parameter_list>(<parameter><decl><type><name>split_size_or_sections</name></type></decl></parameter>)</parameter_list>;</function_decl>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>sv</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>sizes</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><name><name>sv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name><name>Dim</name><operator>::</operator><name>check_exact</name></name><argument_list>(<argument><expr><call><name><name>sizes</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>all_ints</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
                <expr_stmt><expr><name>all_dims</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>all_ints</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>dim_is_object</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"when dim is specified as a Dim object, split sizes must also be dimensions."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="line">// call original split (if self has dimensions this will use torch function to do the split)</comment>
        <return>return <expr><call><name><name>torch_Tensor_split</name><operator>.</operator><name>call_vector</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>vector_args</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>all_dims</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"split list must be ints or dims but got a mix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>self_info</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>ndim</name> <init>= <expr><call><name><name>self_info</name><operator>.</operator><name>ndim</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dim_is_object</name><operator>&amp;&amp;</operator> <name>ndim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"split expects at least a 1-dimension tensor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>DimEntry</name></type> <name>dim_l</name> <init>= <expr><ternary><condition><expr><call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>_wrap_dim</name><argument_list>(<argument><expr><name>dim</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><name>ndim</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>idx</name> <init>= <expr><call><name><name>self_info</name><operator>.</operator><name>levels</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>dim_l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>idx</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>from_int</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"tensor does not comtain dimension %R"</literal></expr></argument>, <argument><expr><call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>indices</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int64_t</name></type> <name>total_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>unbound</name></decl>;</decl_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>sizes</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>d</name><operator>-&gt;</operator><name>is_bound</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>d</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>total_size</name> <operator>+=</operator> <call><name><name>indices</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><call><name><name>indices</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>unbound</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name>auto</name></type> <name>tensor_size</name> <init>= <expr><call><name><name>self_info</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>sizes</name></name><argument_list>()</argument_list></call><index>[<expr><operator>*</operator><name>idx</name></expr>]</index></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>unbound</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>total_size</name> <operator>&gt;</operator> <name>tensor_size</name></expr>)</condition> <block>{<block_content>
           <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"sizes of target dimensions add up to more (%d) than source dim (%d)"</literal></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>tensor_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>remaining_size</name> <init>= <expr><name>tensor_size</name> <operator>-</operator> <name>total_size</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>chunk_size</name> <init>= <expr><operator>(</operator><name>remaining_size</name> <operator>+</operator> <call><name><name>unbound</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <call><name><name>unbound</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>u</name> <range>: <expr><name>unbound</name></expr></range></decl></init>)</control> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>sz</name> <init>= <expr><call><name><name>std</name><operator>::</operator><name>min</name></name><argument_list>(<argument><expr><name>chunk_size</name></expr></argument>, <argument><expr><name>remaining_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name><name>sizes</name><index>[<expr><name>u</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>set_size</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>indices</name><index>[<expr><name>u</name></expr>]</index></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining_size</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tensor_size</name> <operator>!=</operator> <name>total_size</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr><literal type="string">"sum of sizes of target dimensions (%d) do not match the than source dim (%d)"</literal></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>tensor_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>result_tensors</name> <init>= <expr><call><name><name>self_info</name><operator>.</operator><name>tensor</name><operator>-&gt;</operator><name>split_with_sizes</name></name><argument_list>(<argument><expr><call><name><name>at</name><operator>::</operator><name>IntArrayRef</name></name><argument_list>(<argument><expr><call><name><name>indices</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>indices</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>result</name><argument_list>(<argument><expr><call><name><name>result_tensors</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>new_levels</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>self_info</name><operator>.</operator><name>levels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>sizes</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
        <expr_stmt><expr><name><name>new_levels</name><index>[<expr><operator>*</operator><name>idx</name></expr>]</index></name> <operator>=</operator> <call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name><name>sizes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>result</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name><name>result_tensors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_levels</name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><call><name><name>result</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>

    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
}


static <function><type><name>DimEntry</name></type> <name>_wrap_dim</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepdim</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name><name>Dim</name><operator>::</operator><name>check</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>keepdim</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"cannot preserve first-class dimensions with keepdim=True"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><call><name><name>Dim</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>py</name><operator>::</operator><name>is_int</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>i</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>i</name> <operator>-=</operator> <name>N</name></expr>;</expr_stmt>
        </block_content>}</block></while>
        <return>return <expr><name>i</name></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><call><name>DimEntry</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>_wrap_dims</name><parameter_list>(<parameter><decl><type><name>Arena</name><modifier>&amp;</modifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>N</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>keepdim</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>auto</name></type> <name>de</name> <init>= <expr><call><name>_wrap_dim</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>keepdim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>r</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>de</name><operator>.</operator><name>is_none</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>sequence_view</name></name></type> <name>sq</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>sq</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>_wrap_dim</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><name><name>sq</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>keepdim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>WrappedOperator</name> <super_list>: <super><specifier>public</specifier> <name><name>py</name><operator>::</operator><name>base</name><argument_list type="generic">&lt;<argument><expr><name>WrappedOperator</name></expr></argument>&gt;</argument_list></name></super></super_list> <block>{<public type="default">
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>orig</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PyMethodDef</name></type> <name>method_def</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>name</name></decl>, <decl><type ref="prev"/><name>doc</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>is_pointwise</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>dim_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64_t</name></type> <name>keepdim_offset</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>dim_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>single_dim</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>reduce</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Type</name></decl>;</decl_stmt>

    <function><type><name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>orig_</name></decl></parameter>, <parameter><decl><type><name>PyCFunction</name></type> <name>wrapper_implementation</name></decl></parameter>, <parameter><decl><type><name><name>std</name><operator>::</operator><name>string</name></name></type> <name>dim_name_</name><init>=<expr><literal type="string">""</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
        <expr_stmt><expr><name>orig</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>orig_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>method_def</name><operator>.</operator><name>ml_meth</name></name> <operator>=</operator> <name>wrapper_implementation</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name><name>orig</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"__name__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name><name>orig</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"__doc__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dim_name</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>dim_name_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>dim_name</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>doc</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>unicode_from_format</name></name><argument_list>(<argument><expr><literal type="string">"%S\nArgument '%s' can be either an integer or a torchdim.Dim object.\n"</literal></expr></argument>, <argument><expr><call><name><name>doc</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>dim_name</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>method_def</name><operator>.</operator><name>ml_name</name></name> <operator>=</operator> <ternary><condition><expr><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name>PyUnicode_AsUTF8</name><argument_list>(<argument><expr><call><name><name>name</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>method_def</name><operator>.</operator><name>ml_doc</name></name> <operator>=</operator> <ternary><condition><expr><call><name><name>py</name><operator>::</operator><name>is_none</name></name><argument_list>(<argument><expr><name>doc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><call><name>PyUnicode_AsUTF8</name><argument_list>(<argument><expr><call><name><name>doc</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>method_def</name><operator>.</operator><name>ml_flags</name></name> <operator>=</operator> <name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>;</expr_stmt>
    </block_content>}</block></function>

    <function><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>function</name><parameter_list>()</parameter_list> <block>{<block_content>
        <return>return <expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>checked_steal</name></name><argument_list>(<argument><expr><call><name>PyCFunction_New</name><argument_list>(<argument><expr><operator>&amp;</operator><name>method_def</name></expr></argument>, <argument><expr><call><name>ptr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

</public>}</block>;</struct>

<decl_stmt><decl><type><name>PyTypeObject</name></type> <name><name>WrappedOperator</name><operator>::</operator><name>Type</name></name> <init>= <expr><block>{
    <expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
    <literal type="string">"_C.WrappedOperator"</literal></expr>,               <comment type="block">/* tp_name */</comment>
    <expr><sizeof>sizeof<argument_list>(<argument><expr><name>WrappedOperator</name></expr></argument>)</argument_list></sizeof></expr>,               <comment type="block">/* tp_basicsize */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_itemsize */</comment>
    <expr><name><name>WrappedOperator</name><operator>::</operator><name>dealloc_stub</name></name></expr>,      <comment type="block">/* tp_dealloc */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_vectorcall_offset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_getattr */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_setattr */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_async */</comment>
    <expr><literal type="number">0</literal></expr>,           <comment type="block">/* tp_repr */</comment>
    <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* tp_as_number */</comment>
    <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* tp_as_sequence */</comment>
    <expr><literal type="number">0</literal></expr>,             <comment type="block">/* tp_as_mapping */</comment>
    <expr><literal type="number">0</literal></expr>,      <comment type="block">/* tp_hash */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_call */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_str */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_getattro */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_setattro */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_as_buffer */</comment>
    <expr><name>Py_TPFLAGS_DEFAULT</name></expr>, <comment type="block">/* tp_flags */</comment>
    <expr><literal type="string">"Wrapped Object Holder"</literal></expr>,                   <comment type="block">/* tp_doc */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_traverse */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_clear */</comment>
    <expr><literal type="number">0</literal></expr>,  <comment type="block">/* tp_richcompare */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_weaklistoffset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_iter */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_iternext */</comment>
    <expr><literal type="number">0</literal></expr>,                <comment type="block">/* tp_methods */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_members */</comment>
    <expr><literal type="number">0</literal></expr>,             <comment type="block">/* tp_getset */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_base */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_dict */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_descr_get */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_descr_set */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_dictoffset */</comment>
    <expr><literal type="number">0</literal></expr>,            <comment type="block">/* tp_init */</comment>
    <expr><literal type="number">0</literal></expr>,                              <comment type="block">/* tp_alloc */</comment>
    <expr><name><name>WrappedOperator</name><operator>::</operator><name>new_stub</name></name></expr>,                      <comment type="block">/* tp_new */</comment>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>patched_dim_method</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type> <name>self_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>self</name> <init>= <expr><call><name><name>WrappedOperator</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>self_</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name>

    <name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>va</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>_getarg</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>offset_</name></decl></parameter>)</parameter_list> -&gt; <type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>offset</name> <init>= <expr><name>offset_</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="line">// do not include self</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>idx</name> <init>= <expr><call><name><name>va</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><ternary><condition><expr><name>idx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><call><name><name>py</name><operator>::</operator><name>handle</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name><name>va</name><index>[<expr><name>idx</name></expr>]</index></name></expr></else></ternary></expr>;</return>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name><name>py</name><operator>::</operator><name>handle</name></name></expr></argument>&gt;</argument_list></name></type> <name>patched_args</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>patched_args</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>va</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>va</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>_patcharg</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>offset_</name></decl></parameter>, <parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>offset</name> <init>= <expr><name>offset_</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="line">// do not include self</comment>
        <decl_stmt><decl><type><name>auto</name></type> <name>idx</name> <init>= <expr><call><name><name>va</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"Missing argument %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>patched_args</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>dim</name> <init>= <expr><call><name>_getarg</name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>dim_name</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>dim_offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>info</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="boolean">true</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EnableAllLayers</name></type> <name>l</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>levels</name></name></expr></argument>)</argument_list></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>l</name><operator>.</operator><name>inplace_update_layers</name></name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>batchedtensor</name></name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>levels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>patched_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>handle_from_tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>batchedtensor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>auto</name></type> <name>r</name> <init>= <expr><call><name><name>self</name><operator>-&gt;</operator><name>orig</name><operator>.</operator><name>call_vector</name></name><argument_list>(<argument><expr><call><name><name>patched_args</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>l</name><operator>.</operator><name>from_batched</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>THPVariable_Unpack</name><argument_list>(<argument><expr><call><name><name>r</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>has_device</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>info</name> <init>= <expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>keepdim</name> <init>= <expr><literal type="boolean">false</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>reduce</name></name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>py_keepdim</name> <init>= <expr><call><name>_getarg</name><argument_list>(<argument><expr><literal type="string">"keepdim"</literal></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>keepdim_offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name><name>py_keepdim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>keepdim</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>to_bool</name></name><argument_list>(<argument><expr><name>py_keepdim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>ndim</name> <init>= <expr><call><name><name>info</name><operator>.</operator><name>ndim</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>dims</name> <init>= <expr><call><name>_wrap_dims</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>keepdim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></type> <name>dim_indices</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>seen</name> <init>= <expr><call><name><name>A</name><operator>.</operator><name>allocate</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>info</name><operator>.</operator><name>levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>std</name><operator>::</operator><name>fill</name></name><argument_list>(<argument><expr><name>seen</name></expr></argument>, <argument><expr><name>seen</name> <operator>+</operator> <call><name><name>info</name><operator>.</operator><name>levels</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><decl><type><name>auto</name></type> <name>d</name> <range>: <expr><name>dims</name></expr></range></decl></init>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>midx</name> <init>= <expr><call><name><name>info</name><operator>.</operator><name>levels</name><operator>.</operator><name>index</name></name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>midx</name></expr>)</condition> <block>{<block_content>
            <decl_stmt><decl><type><name>auto</name></type> <name>tup</name> <init>= <expr><call><name>levels_to_tuple</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>levels</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>py</name><operator>::</operator><name>raise_error</name></name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><literal type="string">"Tensor with dimensions %R does not contain one of %R\n"</literal></expr></argument>, <argument><expr><call><name><name>tup</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>seen</name><index>[<expr><operator>*</operator><name>midx</name></expr>]</index></name> <operator>=</operator> <literal type="boolean">true</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>dim_indices</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>*</operator><name>midx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <decl_stmt><decl><type><name><name>Slice</name><argument_list type="generic">&lt;<argument><expr><name>DimEntry</name></expr></argument>&gt;</argument_list></name></type> <name>new_levels</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>reduce</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>keepdim</name></expr>)</condition> <block>{<block_content>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>info</name><operator>.</operator><name>levels</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name><name>new_levels</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>levels</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>new_levels</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>levels</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>py_indices</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>dim_indices</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>py_indices</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>from_int</name></name><argument_list>(<argument><expr><name><name>dim_indices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>tup</name><argument_list>(<argument><expr><call><name><name>dim_indices</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
        <for>for <control>(<init><decl><type><name>auto</name></type> <name>i</name> <range>: <expr><call><name><name>dim_indices</name><operator>.</operator><name>enumerate</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
            <expr_stmt><expr><call><name><name>tup</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>from_int</name></name><argument_list>(<argument><expr><name><name>dim_indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>py_indices</name> <operator>=</operator> <call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>_patcharg</name><argument_list>(<argument><expr><call><name><name>self</name><operator>-&gt;</operator><name>dim_name</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>dim_offset</name></name></expr></argument>, <argument><expr><name>py_indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>patched_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>handle_from_tensor</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>tensor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>r</name> <init>= <expr><call><name><name>self</name><operator>-&gt;</operator><name>orig</name><operator>.</operator><name>call_vector</name></name><argument_list>(<argument><expr><call><name><name>patched_args</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>wrap</name> <init>= <expr><lambda><capture>[<argument><modifier>&amp;</modifier></argument>]</capture><parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>THPVariable_Check</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
            <return>return <expr><call><name><name>A</name><operator>.</operator><name>autorelease</name></name><argument_list>(<argument><expr><call><name><name>Tensor</name><operator>::</operator><name>from_positional</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name>THPVariable_Unpack</name><argument_list>(<argument><expr><call><name><name>h</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_levels</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>has_device</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>h</name></expr>;</return>
    </block_content>}</block></lambda></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>tree_map</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>wrap</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>_wrap</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type> <name>self_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGS</name><parameter_list>(<parameter><type><name>_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_(py::handle, orig) _(py::handle, dim_offset) _(py::handle, keepdim_offset) \
                    _(py::handle, dim_name) _(py::handle, single_dim) _(py::handle, reduce)</cpp:value></cpp:define>
    <name>MPY_PARSE_ARGS_KWNAMES</name><argument_list>(<argument><expr><literal type="string">"O|OOOOO"</literal></expr></argument>, <argument><expr><name>ARGS</name></expr></argument>)</argument_list>

    <name><name>std</name><operator>::</operator><name>string</name></name> <name>dim_name_str</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>dim_name</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>dim_name_str</name> <operator>=</operator> <call><name>PyUnicode_AsUTF8</name><argument_list>(<argument><expr><call><name><name>dim_name</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>dim_name_str</name> <operator>=</operator> <literal type="string">"dim"</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>info</name> <init>= <expr><call><name><name>WrappedOperator</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>patched_dim_method</name></expr></argument>, <argument><expr><call><name><name>std</name><operator>::</operator><name>move</name></name><argument_list>(<argument><expr><name>dim_name_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>dim_offset</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dim_offset</name></name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>dim_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>keepdim_offset</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>keepdim_offset</name></name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name>keepdim_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name><name>single_dim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>single_dim</name></name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>to_bool</name></name><argument_list>(<argument><expr><name>single_dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name><name>reduce</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>reduce</name></name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>to_bool</name></name><argument_list>(<argument><expr><name>reduce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name><name>info</name><operator>-&gt;</operator><name>function</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ARGS</name></cpp:undef>

    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>call_torch_function</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>maybeInitializeGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>info</name> <init>= <expr><call><name><name>WrappedOperator</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>__torch_function__</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>orig</name></name></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>vector_args</name></name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>is_pointwise</name></name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>_wrap_method</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>self</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>AT_ASSERT</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <comment type="line">// XXX - ignore python function wrapped, we will call torch function directly</comment>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>orig</name> <init>= <expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>pointwise</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>auto</name></type> <name>dim</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>import</name></name><argument_list>(<argument><expr><literal type="string">"functorch.dim"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>pointwise</name> <operator>=</operator> <call><name><name>dim</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"pointwise"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>info</name> <init>= <expr><call><name><name>WrappedOperator</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>call_torch_function</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>is_pointwise</name></name> <operator>=</operator> <call><name><name>pointwise</name><operator>.</operator><name>contains</name></name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>PyInstanceMethod_New</name><argument_list>(<argument><expr><call><name><name>info</name><operator>-&gt;</operator><name>function</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <expr_stmt><expr><call><name>PY_END</name><argument_list>(<argument><expr><literal type="null">nullptr</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>PyObject</name><modifier>*</modifier></type> <name>Tensor_sum</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type> <name>self_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>maybeInitializeGlobals</name><argument_list>()</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>va</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>self_</name> <init>= <expr><call><name><name>Tensor</name><operator>::</operator><name>unchecked_wrap</name></name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>d</name> <init>= <expr><call><name><name>self_</name><operator>-&gt;</operator><name>delayed</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>d</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><call><name><name>_Tensor_sum</name><operator>.</operator><name>call_vector</name></name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>self</name></decl>, <decl><type ref="prev"/><name>dim</name></decl>, <decl><type ref="prev"/><name>keepdim</name></decl>, <decl><type ref="prev"/><name>dtype</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>va</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"sum"</literal></expr></argument>, <block>{<block_content><expr><literal type="string">"self"</literal></expr><operator>,</operator> <expr><literal type="string">"dim"</literal></expr><operator>,</operator> <expr><literal type="string">"keepdim"</literal></expr><operator>,</operator> <expr><literal type="string">"dtype"</literal></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <block>{<block_content><expr><operator>&amp;</operator><name>self</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>dim</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>keepdim</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>dtype</name></expr></block_content>}</block><operator>,</operator> <expr_stmt><expr><literal type="number">1</literal></expr><operator>,</operator> <expr><literal type="number">1</literal></expr></expr_stmt>)</block_content></block>;</function>

    <if_stmt><if>if <condition>(<expr><call><name><name>dtype</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><call><name><name>keepdim</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>py</name><operator>::</operator><name>to_bool</name></name><argument_list>(<argument><expr><name>keepdim</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
        <comment type="line">// std::cout &lt;&lt; "SKIPPING fusion because dtype or keepdim=True specified\n";</comment>
        <return>return <expr><call><name><name>_Tensor_sum</name><operator>.</operator><name>call_vector</name></name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>levels</name> <init>= <expr><call><name><name>self_</name><operator>-&gt;</operator><name>levels</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>auto</name></type> <name>N</name> <init>= <expr><call><name>ndim_of_levels</name><argument_list>(<argument><expr><name>levels</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>reduced_dims</name> <init>= <expr><call><name>_wrap_dims</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>dot</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>TensorInfo</name><operator>::</operator><name>create</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="boolean">false</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reduced_dims</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>release</name><argument_list>()</argument_list></call></expr>;</return>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
}

static <function><type><name>PyObject</name><modifier>*</modifier></type> <name>_parse_test</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type> <name>self_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name></type>
    <name>maybeInitializeGlobals</name><argument_list>()</argument_list></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>required</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>kwonly</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>to_int</name></name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>va</name><argument_list>(<argument><expr><name>args</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>nargs</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>


    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>, <decl><type ref="prev"/><name>c</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>va</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"_parse_test"</literal></expr></argument>, <block>{<block_content><expr><literal type="string">"a"</literal></expr><operator>,</operator> <expr><literal type="string">"b"</literal></expr><operator>,</operator> <expr><literal type="string">"c"</literal></expr><operator>,</operator> <expr><literal type="string">"d"</literal></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <block>{<block_content><expr><operator>&amp;</operator><name>a</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>b</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>c</name></expr><operator>,</operator> <expr><operator>&amp;</operator><name>d</name></expr></block_content>}</block><operator>,</operator> <expr_stmt><expr><name>required</name></expr><operator>,</operator> <expr><name>kwonly</name></expr></expr_stmt>)</block_content></block>;</function>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>tuple</name></name></type> <name>r</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>a</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>Py_None</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>b</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>b</name></expr> </then><else>: <expr><name>Py_None</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>c</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>c</name></expr> </then><else>: <expr><name>Py_None</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name><name>r</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>borrow</name></name><argument_list>(<argument><expr><ternary><condition><expr><call><name><name>d</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>d</name></expr> </then><else>: <expr><name>Py_None</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name><name>r</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>

    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
}

static <function><type><name>PyObject</name><modifier>*</modifier></type> <name>_set_pointwise_optimize</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type> <name>self_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>
    <name><name>py</name><operator>::</operator><name>handle</name></name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>vector_args</name></name></type> <name>va</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>kwnames</name></expr></argument>)</argument_list></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>va</name><operator>.</operator><name>parse</name></name><argument_list>(<argument><expr><literal type="string">"_set_pointwise_optimization"</literal></expr></argument>, <block>{<block_content><expr><literal type="string">"value"</literal></expr></block_content>}</block></argument_list></call></expr></expr_stmt><operator>,</operator> <block>{<block_content><expr><operator>&amp;</operator><name>value</name></expr></block_content>}</block><operator>,</operator> <expr_stmt><expr><literal type="number">1</literal></expr></expr_stmt>)</block_content></block>;</function>
    <expr_stmt><expr><name>pointwise_optimize</name> <operator>=</operator> <call><name><name>py</name><operator>::</operator><name>to_bool</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
}

static <function><type><name>PyObject</name><modifier>*</modifier></type> <name>_patch_tensor_class</name><parameter_list>(<parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type> <name>self_</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>args</name></decl></parameter>,
                      <parameter><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl></parameter>,
                      <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>kwnames</name></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>PY_BEGIN</name>

    <specifier>auto</specifier></type> <name>torch</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>import</name></name><argument_list>(<argument><expr><literal type="string">"torch"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>auto</name></type> <name>py_TensorBase</name> <init>= <expr><call><name><name>torch</name><operator>.</operator><name>attr</name></name><argument_list>(<argument><expr><literal type="string">"_C"</literal></expr></argument>)</argument_list></call><operator>.</operator><call><name>attr</name><argument_list>(<argument><expr><literal type="string">"_TensorBase"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>replaceMappingIfMatches</name><argument_list>(<argument><expr><name>py_TensorBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
    <macro><name>PY_END</name><argument_list>(<argument><literal type="null">nullptr</literal></argument>)</argument_list></macro>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>dims_doc</name> <init>= <expr><literal type="string">R"""(
dims(n=None, sizes=None) -&gt; torchdim.Dim or Tuple[torchdim.Dim, ...]

Creates and returns one or more Dim objects.

Arg:
    n (int, optional): The number of dimensions to create. Can be omitted if sizes is specified.
    sizes (List[Optional[int]], optional): A list the same size as the number of dimensions to be
      created, specifying each dimensions size, or None to leave the size unset.

Example::
    &gt;&gt;&gt; batch, channel, width, height = dims(4)
    &gt;&gt;&gt; batch, channel, width, height = dims(sizes=[None, 3, 224, 224])
)"""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>methods</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{<expr><literal type="string">"dims"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name><name>_dims</name><argument_list type="generic">&lt;<argument><expr><name>create_dim</name></expr></argument>&gt;</argument_list></name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>, <expr><name>dims_doc</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"dimlists"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name><name>_dims</name><argument_list type="generic">&lt;<argument><expr><name>create_dimlist</name></expr></argument>&gt;</argument_list></name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_test_c"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>test_c</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_wrap_method"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>_wrap_method</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Tensor_from_positional"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py_Tensor_from_positional</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"__torch_function__"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py___torch_function__</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"tree_flatten"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py_tree_flatten</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"order"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>order</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"index"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py_index</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"stack"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py_stack</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"split"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py_split</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"expand"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>expand</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"__getitem__"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py___getitem__</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"__setitem__"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>py___setitem__</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_wrap"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>_wrap</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"Tensor_sum"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>Tensor_sum</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_parse_test"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>_parse_test</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_set_pointwise_optimize"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>_set_pointwise_optimize</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><literal type="string">"_patch_tensor_class"</literal></expr>, <expr><operator>(</operator><name>PyCFunction</name><operator>)</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name>_patch_tensor_class</name></expr>, <expr><name>METH_FASTCALL</name> <operator>|</operator> <name>METH_KEYWORDS</name></expr>}</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>        <comment type="block">/* Sentinel */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>PyModuleDef</name></name></type> <name>module_def</name> <init>= <expr><block>{
    <expr><name>PyModuleDef_HEAD_INIT</name></expr>,
    <expr><literal type="string">"_C"</literal></expr>,   <comment type="block">/* name of module */</comment>
    <expr><name>NULL</name></expr>, <comment type="block">/* module documentation, may be NULL */</comment>
    <expr><operator>-</operator><literal type="number">1</literal></expr>,       <comment type="block">/* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */</comment>
    <expr><name>methods</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>PyObject</name><modifier>*</modifier></type> <name>Dim_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
    <decl_stmt><decl><type><name>Arena</name></type> <name>A</name></decl>;</decl_stmt>
    <try>try <block>{<block_content>
        <decl_stmt><decl><type><name><name>py</name><operator>::</operator><name>object</name></name></type> <name>mod</name> <init>= <expr><call><name><name>py</name><operator>::</operator><name>object</name><operator>::</operator><name>checked_steal</name></name><argument_list>(<argument><expr><call><name>PyModule_Create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>module_def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Dim</name><operator>::</operator><name>ready</name></name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"Dim"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>DimList</name><operator>::</operator><name>ready</name></name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"DimList"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Tensor</name><operator>::</operator><name>ready</name></name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"Tensor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>WrappedOperator</name><operator>::</operator><name>ready</name></name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="string">"_WrappedOperator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><operator>&amp;</operator><name>PyInstanceMethod_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><call><name><name>mod</name><operator>.</operator><name>ptr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"_instancemethod"</literal></expr></argument>, <argument><expr><operator>(</operator><name>PyObject</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>PyInstanceMethod_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>initializeGlobals</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>mod</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block> <catch>catch<parameter_list>(<parameter><decl><type><name><name>py</name><operator>::</operator><name>exception_set</name></name><modifier>&amp;</modifier></type> <name>err</name></decl></parameter>)</parameter_list> <block>{<block_content>
        <return>return <expr><literal type="null">nullptr</literal></expr>;</return>
    </block_content>}</block></catch></try>
</block_content>}</block></function>
</unit>
